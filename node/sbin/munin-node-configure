#!/usr/bin/perl -w
# -*- cperl -*-
#
# Copyright (C) 2003-2006 Jimmy Olsen, Nicolai Langfeldt.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2 dated June,
# 1991.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Program to suggest what plugins to use and not

use strict;
use warnings;

use Getopt::Long;
use POSIX ();
use File::Basename;

use Data::Dumper;
use Carp;

use Munin::Node::Config;
use Munin::Node::Service;
use Munin::Common::Defaults;

my $config = Munin::Node::Config->instance();

my $timeout = 10;

my @all_families     = qw/auto manual contrib/;
my @default_families = qw/auto/;


sub main
{
	parse_args();

	my $plugins = load_available_plugins();
	load_installed_plugins($plugins);

	if (@{ $config->{snmp} }) {
		init_snmp($plugins);
		probe_snmp_hosts($config->{snmp}, $plugins);
		show_suggestions($plugins);
	}
	elsif ($config->{suggest} or $config->{shell}) {
		gather_suggestions($plugins);
		show_suggestions($plugins);
	}
	else {
		print_status_list($plugins);
	}

	exit 0 unless list_errors();

	print STDERR "# The following plugins caused errors:\n";
	foreach my $err (list_errors()) {
		print STDERR "# $err\n";
	}

	exit 1;
}


sub parse_args
{
	my $conffile   = "$Munin::Common::Defaults::MUNIN_CONFDIR/munin-node.conf";
	my $servicedir = "$Munin::Common::Defaults::MUNIN_CONFDIR/plugins";
	my $sconfdir   = "$Munin::Common::Defaults::MUNIN_CONFDIR/plugin-conf.d";
	my $libdir     = "$Munin::Common::Defaults::MUNIN_LIBDIR/plugins";

	my $debug;
	my ($suggest, $shell, $removes, $newer);
	my $exit_not_error  = 1;

	my @families;

	my @snmp;
	my $snmpver  = '2c';
	my $snmpcomm = 'public';
	my $snmpport = 161;

	print_usage_and_exit() unless GetOptions(
		"help"            => \&print_usage_and_exit,
		"shell!"          => \$shell,
		"exitnoterror!"   => \$exit_not_error,
		"debug!"          => \$debug,
		"suggest!"        => \$suggest,
		"config=s"        => \$conffile,
		"servicedir=s"    => \$servicedir,
		"sconfdir=s"      => \$sconfdir,
		"remove-also!"    => \$removes,
		"libdir=s"        => \$libdir,
		"families=s"      => \@families,
		"version!"        => \&print_version_and_exit,
		"snmp=s"          => \@snmp,
		"snmpversion=s"   => \$snmpver,
		"snmpcommunity=s" => \$snmpcomm,
		"snmpport=i"      => \$snmpport,
		"newer=s"         => \$newer
	);

	$config->parse_config_from_file($conffile);

	# Sanity-check arguments
	if ($newer and $newer !~ /^\d+\.\d+\.\d+/) {
		# FIXME: not a very good warning....
		warn "# ERROR: $newer is not a valid argument to --newer.  Ignoring.\n";
		undef $newer;
	}

	if ($newer and (!$shell or $removes)) {
	    print STDERR "Fatal: --newer only supported along with --shell.\n";
	    exit 2;
	}

	if (@families) {
	    @families = split(/,/, $families[0]);
	} else {
	    if (@snmp) {
		@families = ('snmpauto');
	    }
	    elsif ($suggest or $shell) {
		@families = @default_families;
	    }
	    else {
		@families = @all_families;
	    }
	}

	$config->reinitialize({
		timeout => $timeout,

		%$config,

		newer => $newer,
		shell => $shell,
		exit_not_error => $exit_not_error,
		suggest => $suggest,
		remove_also => $removes,

		families => \@families,

		conffile => $conffile,
		servicedir => $servicedir,
		sconfdir => $sconfdir,
		libdir => $libdir,

		snmp => \@snmp,
		snmp_version => $snmpver,
		snmp_community => $snmpcomm,
		snmp_port => $snmpport,

		DEBUG => $debug,
	});

	return;
}


sub print_usage_and_exit
{
	my $all_families     = join(', ', @all_families);
	my $default_families = join(', ', @default_families);

	print qq{Usage: $0 [options]

Options:
	--help			View this help page
	--version		Show version information

	--debug                 View debug information (very verbose).  All
                                debugging output is printed on STDOUT but each
                                line is prefixed with '#'.  Only errors are
                                printed on STDERR.

	--config <file>         Override configuration file
	                        [$Munin::Common::Defaults::MUNIN_CONFDIR/munin.conf]
	--servicedir <dir>	Override plugin directory
	                        [$Munin::Common::Defaults::MUNIN_CONFDIR/plugins/]
	--sconfdir <dir>	Override plugin configuration directory
	                        [$Munin::Common::Defaults::MUNIN_CONFDIR/plugin-conf.d]
	--libdir <dir>		Override plugin lib
	                        [$Munin::Common::Defaults::MUNIN_LIBDIR/plugins/]

	--families <family,...>	Override families ($all_families) [$default_families]
	--suggest		Show suggestions instead of status
	--shell			Show shell commands (implies --suggest)
	--exitnoterror          Do not consider non-zero exit-value as error
	--remove-also		Also show rm-commands when doing --shell

	--newer <version>       Only show suggestions related to plugins
	                        included more recently than version <version>.
                                Only supported along with --shell.

	--snmp <host|cidr>      Do SNMP probing on the host or CIDR network
                                (e.g. "192.168.1.0/24"). This may take some
                                time, especially if the probe includes many
                                hosts. This option can be specified multiple
                                times, or once with a comma-separated list, to
                                include more than one host/CIDR.

	--snmpversion <ver>     Set SNMP version (1, 2c or 3) [2c]
	--snmpcommunity <comm>  Set SNMP community string [public]
	--snmpport <port>       Set SNMP port [161]

By default this program shows which plugins are activated on the system.

If you specify --suggest, it will present a table of plugins that will
probably work (according to the plugins' autoconf command).

If you specify --shell, shell commands to install those same plugins
will be printed. These can be reviewed or piped directly into a shell to
install the plugins.

};

	exit 0;
}


sub print_version_and_exit
{
	print qq{munin-node-configure (munin-node) version $Munin::Common::Defaults::MUNIN_VERSION.
Written by Jimmy Olsen

Copyright (C) 2003-2006 Jimmy Olsen

This is free software released under the GNU General Public License. There
is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE. For details, please refer to the file COPYING that is included
with this software or refer to
  http://www.fsf.org/licensing/licenses/gpl.txt
};

	exit 0;
}


sub normal
{
	printf "%-26s | %-4s | %-39s\n", @_;
	return;
}


### Reporting current status ###################################################

# For each available plugin, prints a line detailing whether or not it's
# installed, and (if it's a wildcard plugin) what identities are currently
# in use
sub print_status_list
{
	my ($plugins) = @_;

	normal("Plugin", "Used", "Extra information");
	normal("------", "----", "-----------------");

	foreach my $plug (sort keys %$plugins) {
		my $plugin = $plugins->{$plug};
		
		my @installed = @{$plugin->{installed}};
		my $now = @installed ? "yes" : "no";

		my $suggestions = '';
		if ($plugin->{wildcard} and @installed) {
			$suggestions = join ' ', @installed;
		}
		normal($plug, $now, $suggestions);
	}

	return;
}


### Reporting and managing suggestions #########################################

# reports which wildcard plugin identities should be added, removed,
# or left as they are.  in (sort of) mathematical terms:
# 	(remove) = (installed) \ (suggested)
# 	(add)    = (suggested) \ (installed)
# 	(same)   = (installed) â‹‚ (suggested)
sub diff_suggestions
{
	my ($installed, $suggested) = @_;

	$installed ||= [];
	$suggested ||= [];

	my (%remove, %add, %same);
	@remove{ @$installed } = ();
	@add{ @$suggested }    = ();
	@same{ @$installed }   = (1) x scalar @$installed;

	foreach my $to_remove (@$suggested) {
		delete $remove{$to_remove};
	}

	foreach my $to_add (@$installed) {
		delete $add{$to_add};
	}

	my @same = grep $same{$_}, @$suggested;

	my @add    = sort keys %add;
	my @remove = sort keys %remove;

	return (\@same, \@add, \@remove);
}


# Asks each available autoconf plugin whether or not it should be installed,
# and (if it's a wildcard plugin) its suggested profiles.
sub gather_suggestions
{
	my ($plugins) = @_;

	# We're going to be running plugins
	prepare_plugin_environment();

	foreach my $plug_info (values %$plugins) {
		next unless $plug_info->{capabilities}{autoconf};

		fetch_plugin_autoconf($plug_info);

		fetch_plugin_suggestions($plug_info)
			if ($plug_info->{wildcard}
			and $plug_info->{capabilities}{suggest});
	}

	return;
}


# Displays the suggestions in an appropriate form (shell commands or a table)
sub show_suggestions
{
	my ($plugins) = @_;

	unless ($config->{shell}) {
		normal("Plugin", "Used", "Suggestions");
		normal("------", "----", "-----------");
	}

	foreach my $plugin (sort keys %$plugins) {
		my $plug_info = $plugins->{$plugin};

		next unless $plug_info->{capabilities}{autoconf}
		         or $plug_info->{capabilities}{snmpconf};

		$config->{shell} ? manage_links($plug_info)
		                 : print_suggestion_row($plug_info);
	}

	return;
}


# prints out the tabular representation of the suggestion
sub print_suggestion_row {
  my ($plug_info) = @_;

  my $msg = '';  # either [reason] or (+add/-remove)
  my $now = $plug_info->{installed} ? 'yes' : 'no';

  if ($plug_info->{wildcard}) {
    my ($same, $add, $remove) = diff_suggestions($plug_info->{installed},
						 $plug_info->{suggestions});
    my @suggestions = @$same;
    push @suggestions, map { '+' . $_ } @$add;
    push @suggestions, map { '-' . $_ } @$remove;

    $msg = '(' . join(' ', @suggestions) . ')' if @suggestions;
  }
  elsif ($plug_info->{defaultreason}) {
    # Report why it's not being used
    $msg = "[$plug_info->{defaultreason}]";
  }

  normal($plug_info->{name}, $now, "$plug_info->{default} $msg");
  return;
}


# prints shell commands to get the system into the recommended
# state by adding or removing symlinks
sub manage_links {
  my ($plugin) = @_;

  if ($plugin->{default} eq 'no') {
    # Damnatio memoriae!
    foreach my $link (@{ $plugin->{installed} }) {
      link_remove($link);
    }
  } elsif ($plugin->{wildcard}) {
    # Yes, and wildcard.  Add and remove links to get them in sync
    my ($same, $add, $remove) = diff_suggestions($plugin->{installed},
						 $plugin->{suggestions});
    foreach my $to_add (@$add) {
      link_add($plugin->{name}, $to_add);
    }
    foreach my $to_remove (@$remove) {
      link_remove($plugin->{name}, $to_remove);
    }
  } else {
    # Yes, but not wildcard: just add a straight link
    link_add($plugin->{name});
  }
  return;
}


# If the user requested it, prints a shell-command to remove a given
# symlink from the servicedir
sub link_remove
{
	my $plug = shift;

	return unless $config->{remove_also};
	return unless (-l "$config->{servicedir}/$plug"); # Strange...

	print "rm -f '$config->{servicedir}/$plug'\n";

	return;
}


sub link_add
{
	my $plug = shift;
	my $wild = shift || '';

	my $from = "$config->{libdir}/$plug";
	my $to   = "$config->{servicedir}/$plug$wild";

	print "ln -s '$from' '$to'\n";

	return;
}


### SNMP probing ###############################################################

# Prepares for SNMP probing
sub init_snmp
{
	my $plugins = shift;

	unless (eval { require Munin::Node::SNMPConfig; }) {
		print STDERR "# ERROR: Cannot perform SNMP probing since "
		           . "Munin::Node::SNMPConfig module is not installed.\n";
		print $@;
		exit 1;
	}

	Munin::Node::SNMPConfig->import();

	prepare_plugin_environment();

	foreach my $plug_info (values %$plugins) {
		next unless $plug_info->{capabilities}{snmpconf};
		fetch_plugin_snmpconf($plug_info);
	}

	return;
}


sub probe_snmp_hosts
{
	my ($snmp_hostlist, $plugins) = @_;

	# Allow the user to mix multiple invocations of --snmp with the comma-delimited form
	my @host_specs = map { split /,/ } @$snmp_hostlist;

	# FIXME: should preserve hostnames as much as possible.
	foreach my $host (expand_hosts(@host_specs)) {
		snmp_probe_host($host, $plugins);
	}

	return;
}


### Plugin and service enumeration #############################################

sub load_installed_plugins
{
	my ($plugins) = @_;

	my $service_count = 0;  # the number of services currently installed.

	DEBUG("Searching '$config->{servicedir}' for installed plugins.");

	opendir (my $SERVICEDIR, $config->{servicedir})
		or die "ERROR: Could not open '$config->{servicedir}' for reading: $!\n";

	while (my $service = readdir $SERVICEDIR) {
		my $realfile;
		my $path = "$config->{servicedir}/$service";

		next unless Munin::Node::Service->is_a_runnable_service($service);

		# Ignore non-symlinks, and symlinks that point anywhere other
		# than the plugin library
		next unless -l $path;
		unless ($realfile = readlink($path)) {
			# FIXME: should be a given, since it's tested by is_a_runnable_service()
			DEBUG("Warning: symlink '$config->{servicedir}/$service' is broken.");
			next;
		}
		next unless ($realfile =~ /^$config->{libdir}\//);

		$realfile = fileparse($realfile);

		DEBUG("Found '$service'");

		unless ($plugins->{$realfile}) {
			DEBUG("\tCorresponds to an ignored plugin ($realfile).  Skipping.");
			next;
		}

		if ($plugins->{$realfile}->{wildcard}) {
			DEBUG("\tWildcard plugin '$service' resolves to '$realfile'");

			# FIXME: doesn't work with snmp__* plugins
			(my $wild = $service) =~ s/^$realfile//;

			DEBUG("\tAdding suggestion '$wild'");
			push @{ $plugins->{$realfile}->{installed} }, $wild;
		}

		$service_count++;
	}
	close ($SERVICEDIR);

	DEBUG("$service_count services currently installed.");
	return;
}


sub load_plugin_history
{
	my ($plugins) = @_;

	my $hist_file = "$config->{libdir}/plugins.history";

	my $reached_version = 0;
	my $ver = "0.0.0";

	DEBUG("Loading plugin history from '$hist_file'");

	open(my $HIST, '<', $hist_file)
		or die "# ERROR: Could not open '$hist_file': $!\n";

	# $^O or $Config{osname} are based on the platform perl was built on,
	# not where it's currently running.  This should always be correct
	my $uname = lc((POSIX::uname())[0]);

	while (my $line = <$HIST>) {
		# FIXME: use Munin::Common::Config?
		$line =~ s/#.*//g;
		$line =~ s/^\s+//g;
		$line =~ s/\s+$//g;
		next unless $line =~ /\S/;

		if ($line =~ /^\[([^\]]+)\]$/) {
		    $ver = $1;
		    DEBUG("Setting version to '$ver'.");
		    if ($ver eq $config->{newer}) {
			$reached_version = 1;
		    } elsif ($reached_version) {
			$reached_version++;
		    }
		}
		elsif ($reached_version < 2) {
		    next;
		}
		elsif ($line =~ /^([^\/]+)\/(.+)$/) {
		    if ($uname eq $1) {
			$plugins->{$2}->{version} = $ver;
			DEBUG("- Adding plugin '$2' to version tree ($ver)");
		    }
		}
		elsif ($line =~ /^(.+)$/) {
		    $plugins->{$1}->{version} = $ver;
		    DEBUG("- Adding plugin '$1' to version tree ($ver)");
		}
	}
	close $HIST;

	return;
}


# Extracts any magic-markers from the plugin
sub read_magic_markers
{
	my ($info) = @_;
	my $PLUGIN;

	$info->{family} = 'contrib';
	$info->{capabilities} = {};

	DEBUG("\tReading magic markers.");

	unless (open ($PLUGIN, '<', $info->{path})) {
		DEBUG("Could not open plugin '$info->{path}' for reading: $!");
		return;
	}

	while (<$PLUGIN>) {
		if (/#%#\s+family\s*=\s*(\S+)\s*/) {
			$info->{family} = $1;
			DEBUG("\tSet family to '$1'." );
		}
		elsif (/#%#\s+capabilities\s*=\s*(.+)/) {
			my @caps = split(/\s+/, $1);
			foreach my $capability (@caps) {
				$info->{capabilities}{$capability} = 1;
			}
			DEBUG("\tCapabilities are: ", join(', ', @caps));
		}
	}
	close ($PLUGIN);
	return;
}


sub load_available_plugins
{
	my %found;  # Plugins found

	load_plugin_history() if $config->{newer};

	DEBUG("Searching '$config->{libdir}' for available plugins.");

	opendir (my $LIBDIR, $config->{libdir})
		or die "Fatal: Could not open '$config->{libdir}' for reading: $!\n";

	while (my $plug = readdir $LIBDIR) {
		my $path = "$config->{libdir}/$plug";
		my %plugin = (
			name         => $plug,
			default      => 'no',
			installed    => [],
			suggestions  => [],
			family       => 'contrib',
			capabilities => {},
		);

		unless (Munin::Node::Service->is_a_runnable_service($plug, $config->{libdir})) {
			DEBUG("Ignoring '$path'.");
			next;
		}

		DEBUG("Considering '$path'");

		# FIXME: should there ever be symlinks in here?  do we even need
		# care unless we're going to try running it?
		while (-l $path) {
			$path = readlink($path);
			$path = ($path =~ /^\//) ? $path
			                         : "$config->{libdir}/$path";
		}
		$plugin{path} = $path;  # the absolute path to the script
		$plugin{wildcard}++ if $path =~ /_$/;

		read_magic_markers(\%plugin);

		unless (grep { $plugin{family} eq $_ } @{ $config->{families} }) {
			DEBUG("\tFamily '$plugin{family}' is currently ignored.  Skipping.");
			next;
		}

		if (($plugin{family} eq "auto") and $config->{newer} and $plugin{version}) {
			DEBUG("\tPlugin is older than $config->{newer}.  Skipping.");
			next;
		}

		$found{$plug} = \%plugin;
	}
	close ($LIBDIR);

	DEBUG(sprintf "%u plugins available.", scalar keys %found);
	return \%found;
}


### Running plugins and analysing responses ####################################

sub prepare_plugin_environment
{
	Munin::Common::Defaults->export_to_environment();

	# Export some variables plugins might be interested in
	$ENV{MUNIN_DEBUG} = $config->{PIDEBUG};
	$ENV{FQDN} = $config->{fqdn} || Munin::Node::OS->get_fq_hostname();

	# Some locales uses "," as decimal separator. This can mess up a lot
	# of plugins.
	$ENV{LC_ALL} = 'C';

	$config->{defuser} = getpwnam($Munin::Common::Defaults::MUNIN_PLUGINUSER)
		unless defined $config->{defuser};
	$config->{defgroup} = getgrnam($Munin::Common::Defaults::MUNIN_GROUP)
		unless defined $config->{defgroup};

	$config->process_plugin_configuration_files();
	$config->apply_wildcards();

	return;
}


# Runs the plugin with argument $mode (eg. 'suggest', 'autoconf') and runs
# tests on the results.  Assuming no errors were detected, returns a list
# of the lines printed to STDOUT, with any debug output removed.
sub run_plugin
{
	my ($name, $mode) = @_;

	DEBUG("Running '$mode' on $name" );
	my $res = Munin::Node::Service->fork_service($config->{libdir},
	                                             $name, $mode);

	# No if it timed out
	if ($res->{timed_out}) {
		log_error($name, "Timed out during $mode");
		return;
	}
	elsif ($res->{retval}) {
		# Non-zero exit is an immediate fail
		my $plugin_exit   = $res->{retval} >> 8;
		my $plugin_signal = $res->{retval} & 127;

		# Definitely a bad sign
		if ($plugin_signal) {
			log_error($name,
			          "Died with signal $plugin_signal during $mode");
			return;
		}
		elsif ($plugin_exit) {
			log_error($name, "Non-zero exit during $mode ($plugin_exit)");

			# Verboten according to the specification, but lots of plugins
			# still do it during autoconf.  So making it a non-fatal error
			# for the time being
			return unless ($mode eq 'autoconf'
			           and $plugin_exit == 1
			           and $config->{exit_not_error});
		}
	}

	# No if there is anything on stderr that's not debug
	if (grep !/^#/, @{ $res->{stderr} }) {
		log_error($name, "Junk printed to stderr");
		# FIXME: log the other output
		return;
	}

	# Get the list while ignoring debug output
	return grep !/^#/, @{ $res->{stdout} };
}


# Runs the given plugin, and records whether it thinks it should be installed.
# Sets the 'default' and 'defaultreason' fields
sub fetch_plugin_autoconf
{
	my ($plugin) = @_;

	# Default to the safe option
	$plugin->{default} = 'no';

	my @response = run_plugin($plugin->{name}, 'autoconf');
	return parse_autoconf_response($plugin, @response);
}


sub parse_autoconf_response
{
	my ($plugin, @response) = @_;

	# If there's anything else, it means more than one line was printed
	unless (scalar(@response) == 1) {
		# FIXME: not a good message
		log_error($plugin->{name}, 'Wrong amount of autoconf');
		return;
	}

	my $line = shift @response;

	# The line it did print isn't in a valid format
	unless ($line =~ /^(yes)$/
	     or $line =~ /^(no)(?:\s+\((.*)\))?\s*$/)
	{
		log_error($plugin->{name}, "Junk printed to stdout");
		return;
	}

	# Some recognized response
	DEBUG("\tGot yes/no: $line");

	$plugin->{default} = $1;
	$plugin->{defaultreason} = $2;

	return;
}


# Runs the given wildcard plugin and saves a list of suggested profiles
# in the 'suggestions' field
sub fetch_plugin_suggestions
{
	my ($plugin) = @_;

	# Only run if the autoconf gave the go-ahead
	return unless ($plugin->{default} eq "yes");

	# FIXME: is this required?  there shouldn't be any need to check
	# suggestions if the plugin suffered a fatal error.
	$plugin->{suggestions} = [];

	my @suggested = run_plugin($plugin->{name}, 'suggest');
	return parse_suggest_response($plugin, @suggested);
}


sub parse_suggest_response
{
	my ($plugin, @suggested) = @_;

	foreach my $line (@suggested) {
		if ($line =~ /^[-\w.]+$/) {
			# This looks like it should be a suggestion.
			DEBUG("\tAdded suggestion: $line");
			push @{ $plugin->{suggestions} }, $line;
		}
		else {
			log_error($plugin->{name}, "\tBad suggestion: $line");
		}
	}

	unless (@{ $plugin->{suggestions} }) {
		log_error($plugin->{name}, "No suggestions");
		return;
	}

	return;
}


# Runs a given snmpconf-capable plugin, and notes the parameters it returns
sub fetch_plugin_snmpconf
{
	my ($plugin) = @_;

	my @response = run_plugin($plugin->{name}, 'snmpconf');
	return parse_snmpconf_response($plugin, @response);
}


my $oid_pattern      = qr/^[0-9.]+[0-9]+$/;
my $oid_root_pattern = qr/^[0-9.]+\.$/;

sub parse_snmpconf_response
{
	my ($plugin, @response) = @_;

	foreach my $line (@response) {
		my ($key, $value) = $line =~ /(\w+)\s+(.+\S)/;

		next unless defined $key and defined $value;

		DEBUG("\tAnalysing line: $line");

		if ($key eq 'require') {
			my ($oid, $regex) = split /\s+/, $value, 2;

			if ($oid =~ /$oid_root_pattern/) {
				$oid =~ s/\.$//;
				push @{ $plugin->{require_root} }, [$oid, $regex];

				DEBUG("\tRegistered 'require': $oid");
				DEBUG("\t\tFiltering on /$regex/") if $regex;
			}
			elsif ($oid =~ /$oid_pattern/) {
				push @{ $plugin->{require_oid} }, [$oid, $regex];

				DEBUG("\tRegistered 'require': $oid");
				DEBUG("\t\tFiltering on /$regex/") if $regex;
			}
			else {
				log_error($plugin->{name},
					"Invalid format for 'require': $value");
			}
		}
		elsif ($key eq 'index') {
			if ($plugin->{index}) {
				log_error($plugin->{name}, 'index redefined');
				next;
			}
			unless ($value =~ /$oid_root_pattern/) {
				log_error($plugin->{name}, 'index must be an OID root');
				next;
			}

			($plugin->{index} = $value) =~ s/\.$//;
			DEBUG("\tRegistered 'index'  : $value");
		}
		elsif ($key eq 'number') {
			if ($plugin->{number}) {
				log_error($plugin->{name}, 'number redefined');
				next;
			}

			unless ($value =~ /$oid_pattern/) {
				log_error($plugin->{name}, 'number must be an OID');
				next;
			}

			$plugin->{number} = $value;
			DEBUG("\tRegistered 'number' : $value");
		}
		else {
			log_error($plugin->{name}, "Couldn't parse line: $line");
		}
	}

	return;
}


### Debugging and error reporting ##############################################
my %errors;

# Logs an error against $plugin, and prints it out if debugging is on
sub log_error
{
	my ($plugin, $msg) = @_;

	chomp $msg;
	push @{ $errors{$plugin} }, $msg;

	DEBUG($msg);

	return;
}


sub clear_errors
{
	%errors = ();
	return;
}


sub list_errors
{
	my @error_list;
	while (my ($plugin, $errors) = each %errors) {
		push @error_list, "$plugin:";
		push @error_list, map { "\t$_" } @$errors;
	}
	return @error_list;
}


sub DEBUG { print '# ', @_, "\n" if $config->{DEBUG}; }

exit main() unless caller;


1;

__END__

=head1 NAME

munin-node-configure - View and modify which plugins are enabled

=head1 SYNOPSIS

munin-node-configure [options]

=head1 OPTIONS

=over 5

=item B<< --help >>

View this help page

=item B<< --version >>

Show version information

=item B<< --debug >>

Print debug information (very verbose).  All debugging output is
printed on STDOUT but each line is prefixed with '#'.  Only errors are
printed on STDERR.

=item B<< --config <file> >>

Override configuration file [@@CONFDIR@@/munin-node.conf]

=item B<< --servicedir <dir> >>

Override plugin dir [@@CONFDIR@@/plugins/]

=item B<< --sconfdir <dir> >>

Override plugin configuration directory [@@CONFDIR@@/plugin-conf.d/]

=item B<< --libdir <dir> >>

Override plugin lib [@@LIBDIR@@/plugins/]

=item B<< --families <family,...> >>

Override families (auto, manual, contrib) [auto]

=item B<< --suggest >>

Show suggestions instead of status

=item B<< --shell >>

Show shell commands (implies --suggest)

=item B<< --exitnoterror >>

Do not consider non-zero exit-value as error

=item B<< --remove-also >>

Also show rm-commands when doing --shell

=item B<< --newer <version> >>

Only show suggestions related to plugins included more recently than
version <version>. Only supported along with --shell.

=item B<< --snmp <host|cidr,...> >>

Do SNMP probing on the host or CIDR network
(e.g. "192.168.1.0/24"). This may take some time, especially if the
probe includes many hosts. This option can be specified multiple
times, or once with a comma-separated list, to include more than one
host/CIDR.  Only supported along with --shell.

=item B<< --snmpversion <ver> >>

Set the SNMP version (1, 2c or 3) to use when probing. Default is
"2c".

=item B<< --snmpcommunity <comm> >>

Set SNMP community string to use when probing. Default is "public".

=item B<< --snmpport <port> >>

Set SNMP port. Default is "161".

=back

=head1 DESCRIPTION

Munin's node is a daemon that Munin connects to fetch data. This data
is stored in .rrd-files, and later graphed and htmlified. It's
designed to let it be very easy to graph new datasources.

Munin-node-configure is a script to show the current configuration of
which plugins the host is running, as well as suggestions on what
changes to make to this configuration. It does this by using
munin-run(1) to ask the plugins themselves whether they should be run
or not.

=head1 FILES

	@@CONFDIR@@/munin-node.conf
	@@CONFDIR@@/plugin-conf.d/*
	@@CONFDIR@@/plugins/*
        @@LIBDIR@@/plugins/plugins.history
	@@LIBDIR@@/plugins/*

=head1 VERSION

This is munin-node-configure v@@VERSION@@.

=head1 AUTHORS

Jimmy Olsen, Nicolai Langfeldt

=head1 BUGS

None known.

=head1 COPYRIGHT

Copyright (C) 2003-2006 Jimmy Olsen, Nicolai Langfeldt.

This is free software; see the source for copying conditions. There is
NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.

This program is released under the GNU General Public License

=cut

