#!/usr/bin/perl -w
# -*- perl -*-
#
# Copyright (C) 2003-2006 Jimmy Olsen, Nicolai Langfeldt.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2 dated June,
# 1991.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Program to suggest what plugins to use and not

$| = 1; # Flush after every write to stdout

use strict;
use warnings;

use Getopt::Long;
use POSIX;
use File::Basename;

use Data::Dumper;

use Munin::Node::Config;
use Munin::Node::Service;
use Munin::Common::Defaults;

my $config = Munin::Node::Config->instance();

my $bindir = $Munin::Common::Defaults::MUNIN_SBINDIR;

my @all_families     = ("auto", "manual", "contrib");
my @default_families = ("auto");

my @errors     = ();


sub parse_args
{
	my $conffile   = "$Munin::Common::Defaults::MUNIN_CONFDIR/munin-node.conf";
	my $servicedir = "$Munin::Common::Defaults::MUNIN_CONFDIR/plugins";
	my $libdir     = "$Munin::Common::Defaults::MUNIN_LIBDIR/plugins";

	my $debug;
	my ($suggest, $shell, $removes, $newer);
	my $exiterror  = 1;

	my @families;

	my @snmp;
	my $snmpver    = '2c';
	my $snmpcomm   = 'public';
	my $snmpport   = 161;

	print_usage_and_exit() unless GetOptions(
		"help"            => \&print_usage_and_exit,
		"shell!"          => \$shell,
		"exitnoterror!"   => \$exiterror,
		"debug!"          => \$debug,
		"suggest!"        => \$suggest,
		"config=s"        => \$conffile,
		"servicedir=s"    => \$servicedir,
		"remove-also!"    => \$removes,
		"libdir=s"        => \$libdir,
		"families=s"      => \@families,
		"version!"        => \&print_version_and_exit,
		"snmp=s"          => \@snmp,
		"snmpversion=s"   => \$snmpver,
		"snmpcommunity=s" => \$snmpcomm,
		"snmpport=i"      => \$snmpport,
		"newer=s"         => \$newer
	);

	$config->parse_config_from_file($conffile);

	# Sanity-check arguments
	if ($newer and not $newer =~ /^\d+\.\d+\.\d+/) {
		# FIXME: not a very good warning....
		warn "# ERROR: $newer is not a valid argument to --newer.  Ignoring.\n";
		undef $newer;
	}

	if ($newer and (!$shell or $removes)) {
	    print STDERR "Fatal: --newer only supported along with --shell.\n";
	    exit 2;
	}

	if (@snmp and !$shell) {
	    print STDERR "Fatal: --snmp only supported along with --shell.\n";
	    exit 3;
	}


	if (@families) {
	    @families = split /,/, $families[0];
	} else {
	    if (@snmp) {
		@families = ();
		$shell=1;
	    }
	    elsif ($suggest or $shell) {
		@families = @default_families;
	    }
	    else {
		@families = @all_families;
	    }
	}

	$config->reinitialize({
		%$config,

		newer => $newer,
		shell => $shell,
		exit_not_error => $exiterror,
		suggest => $suggest,
		remove_also => $removes,

		families => \@families,

		conffile => $conffile,
		servicedir => $servicedir,
		libdir => $libdir,

		snmp => \@snmp,
		snmp_version => $snmpver,
		snmp_community => $snmpcomm,
		snmp_port => $snmpport,

		DEBUG => $debug,
	});

	return;
}


sub print_usage_and_exit
{
	my $all_families = join(', ', @all_families);
	my $default_families = join(', ', @default_families);

	print qq{Usage: $0 [options]

Options:
	--help			View this help page
	--version		Show version information
	--debug			View debug information (very verbose)
	--config <file>         Override configuration file
	                        [$config]
	--servicedir <dir>	Override plugin directory
	                        [$Munin::Common::Defaults::MUNIN_CONFDIR/plugins]
	--libdir <dir>		Override plugin lib
	                        [$Munin::Common::Defaults::MUNIN_LIBDIR/plugins]
	--families <family,...>	Override families ($all_families) [$default_families]
	--suggest		Show suggestions instead of status
	--shell			Show shell commands (implies --suggest)
	--exitnoterror          Do not consider non-zero exit-value as error
	--remove-also		Also show rm-commands when doing --shell
	--newer <version>	Only show suggestions related to plugins included
	                        more recently than version <version>.
	--snmp <host|cidr>      Do SNMP probing on the host or CIDR network.
	--snmpversion <ver>     Set SNMP version (1, 2c or 3) [2c]
	--snmpcommunity <comm>  Set SNMP community string [public]
	--snmpport <port>       Set SNMP port [161]

By default this program shows which plugins are activated on the system.

If you specify --suggest, it will present a table of plugins that will
probably work (according to the plugins' autoconf command).

If you specify --shell, shell commands to install those same plugins
will be printed. These can be reviewed or piped directly into a shell to
install the plugins.

};

	exit 0;
}


sub print_version_and_exit
{
	print qq{munin-node-configure (munin-node) version $Munin::Common::Defaults::MUNIN_VERSION.
Written by Jimmy Olsen

Copyright (C) 2003-2006 Jimmy Olsen

This is free software released under the GNU General Public License. There
is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE. For details, please refer to the file COPYING that is included
with this software or refer to
  http://www.fsf.org/licensing/licenses/gpl.txt
};

	exit 0;
}


sub print_header
{
	if ($config->{suggest}) {
		normal("Plugin", "Used", "Suggestions");
		normal("------", "----", "-----------");
	}
	else {
		normal("Plugin", "Used", "Extra information");
		normal("------", "----", "-----------------");
	}

	return;
}


sub main
{
	parse_args();

	my $plugins   = load_available_plugins();
	my $installed = load_installed_plugins();

	print_header() unless $config->{shell};

	if ($config->{suggest}) {
		get_suggestions($plugins);
		#print_suggestions();
	}
	elsif (@{ $config->{snmp} }) {
		# Hand off to munin-node-configure-snmp
		configure_snmp();
	}
	else {
		# FIXME: if $config->{shell}, implies $config->{suggest}
		print_status_list($plugins, $installed);
	}


	exit 0 unless scalar @errors;

	print STDERR "# There were some errors:\n";
	foreach my $err (@errors) {
		print STDERR "#\t$err";
	}

	exit 1;


	###########
	foreach my $plug (sort keys %{$plugins}) {
		my $now   = (exists $installed->{$plug}?"yes":"no");
		my $want  = (exists $plugins->{$plug}->{'default'}?$plugins->{$plug}->{'default'}:"no");
		my $snow  = (exists $installed->{$plug}->{'suggest'}?$installed->{$plug}->{'suggest'}:undef);
		my $swant = (exists $plugins->{$plug}->{'suggest'}?$plugins->{$plug}->{'suggest'}:undef);
		my $sugg  = "";

		if ($config->{shell}) {
			if ($plug =~ /_$/) {
				# wildcard plugin
				if ($now eq "yes" and $want eq "no") {
					if ($snow and @{$snow}) {
						foreach my $wild (sort @{$snow}) {
							link_remove("$plug$wild");
						}
					}
				}
				else {
					if ($snow and @{$snow}) {
						foreach my $wild (sort @{$snow}) {
							if (! grep (/^$wild$/, @{$swant})) {
								link_remove("$plug$wild");
							}
						}
					}
					if ($swant and @{$swant}) {
						foreach my $wild (sort @{$swant}) {
							next if -e "$config->{servicedir}/$plug"."_".$wild;
							if (! grep (/^$wild$/, @{$snow})) {
								link_add($plug, $wild);
							}
						}
					}
				}
			}
			else {
				if ($now eq "yes" and $want eq "no") {
					link_remove($plug);
				}
				elsif ($now eq "no" and $want eq "yes") {
					next if -e "$config->{servicedir}/$plug"; # None of our business...
					link_add($plug);
				}
			}
		}
		elsif ($config->{suggest}) {
			if ($plug =~ /_$/) {
				# wildcard plugin
				if ($now eq "yes" && $want eq "no"
				 or $now eq "no" && $want eq "yes" && $swant && @{$swant})
				{
					$sugg = "$want ";
				}
				if ($snow and @{$snow}) {
					foreach my $wild (sort @{$snow}) {
						if (! grep (/^$wild$/, @{$swant})) {
							$sugg .= "-$wild ";
						}
					}
				}
				if ($swant and @{$swant}) {
					foreach my $wild (sort @{$swant}) {
						next if -e "$config->{servicedir}/$plug"."_".$wild; # None of our business...
						if (! grep (/^$wild$/, @{$snow})) {
							$sugg .= "+$wild ";
						}
					}
				}
				normal($plug, $now, $sugg);
			}
			else {
				next if -e "$config->{servicedir}/$plug"; # None of our business...
				if ($now ne $want) {
					$sugg = $want;
				}
				elsif (defined $plugins->{$plug}->{'defaultreason'}
				   and $plugins->{$plug}->{'defaultreason'} =~ /^[^\(]*\((.+)\)\s*$/)
				{
					$sugg = "[$1]";
				}

				normal($plug, $now, $sugg);
			}
		}
	}

}


# Queries each available autoconf plugin for whether or not it 
# should be installed, and (if it's a wildcard plugin) its suggested profiles
sub get_suggestions
{
	my ($plugins) = @_;

	while (my ($name, $plug_info) = each %$plugins) {
		next unless $plug_info->{capabilities}{autoconf};
		
		plugin_autoconf($name, $plug_info);
		
		if ($plug_info->{default} eq 'yes'
		    and $plug_info->{wildcard}
		    and $plug_info->{capabilities}{suggest})
		{
			plugin_suggestions($name, $plug_info);
		}
	}

	return;
}


# Hands control off to munin-node-configure-snmp to configure SNMP plugins
sub configure_snmp
{
	unless (eval { require Munin::Node::SNMPConfig; }) {
		print STDERR "# ERROR: Cannot perform SNMP probe since Munin::Node::SNMPConfig module is not loaded.\n";
		print $@;

		exit 1;
	}

	die "Not yet implemented...";
}


# For each available plugin, prints a line detailing whether or not it's
# installed, and (if it's a wildcard plugin) what identities are currently
# in use
sub print_status_list
{
	my ($plugins, $installed) = @_;

	foreach my $plug (sort keys %$plugins) {
		my $now   = $installed->{$plug}
		              ? "yes"
		              : "no";
		my $suggested = $installed->{$plug}->{suggest}
		                  ? $installed->{$plug}->{suggest}
		                  : [];

		my $suggestions = '';

		if ($plug =~ /_$/ and @$suggested) {
			# It's a wildcard, and there are suggestions
			$suggestions = join ' ', @$suggested;
		}
		
		normal($plug, $now, $suggestions);
	}
}


# If the user requested it, prints a shell-command to remove a given
# symlink from the servicedir
sub link_remove
{
    my $plug = shift;

    return unless $config->{remove_also};
    return unless (-l "$config->{servicedir}/$plug"); # Strange...

    print "rm -f '$config->{servicedir}/$plug'\n";
}


sub link_add
{
	my $plug = shift;
	my $wild = shift || '';

	my $from = "$config->{libdir}/$plug";
	my $to = "$config->{servicedir}/$plug$wild";

	print "ln -s '$from' '$to'\n";
}


sub normal
{
	printf ("%-26s | %-4s | %-39s\n", @_);
}


sub load_installed_plugins
{
	my %found;  # information on installed plugins
	my $service_count = 0;  # the number of services currently installed.  may not 
	                        # be equal to (keys %found) if some are wildcards
	
	print "# Searching '$config->{servicedir}' for installed plugins.\n"
		if $config->{DEBUG};

	opendir (my $SERVICEDIR, $config->{servicedir})
		or die "ERROR: Could not open '$config->{servicedir}' for reading: $!\n";

	while (my $service = readdir $SERVICEDIR) {
		my $realfile;
		my $path = "$config->{servicedir}/$service";

		# Ignore non-symlinks, and symlinks that point anywhere other
		# than the plugin library
		next unless -l $path;
		unless ($realfile = readlink($path)) {
			print "# Warning: symlink '$config->{servicedir}/$service' is broken.\n";
			next;
		}
		next unless ($realfile =~ /^$config->{libdir}\//);

		$realfile = fileparse($realfile);

		$found{$realfile} ||= {};

		print "# Found '$service'\n" if $config->{DEBUG};

		if ($realfile =~ /_$/) {
			print "#\tWildcard plugin '$service' resolves to '$realfile'\n"
				if $config->{DEBUG};

			# FIXME: doesn't work with snmp__* plugins
			(my $wild = $service) =~ s/^$realfile//;

			print "#\tAdding suggestion '$wild'\n"
				if $config->{DEBUG};

			$found{$realfile}->{wildcard} = 1;

			$found{$realfile}->{suggest} ||= [];
			push @{ $found{$realfile}->{suggest} }, $wild;
		}

		$service_count++;
	}
	close ($SERVICEDIR);

	print "# $service_count services currently installed.\n" if $config->{DEBUG};
	return \%found;
}


sub load_plugin_history
{
	my ($plugins) = @_;
	
	my $hist_file = "$config->{libdir}/plugins.history";

	my $reached_version = 0;
	my $ver = "0.0.0";

	print "# Loading plugin history from '$hist_file'\n"
		if $config->{DEBUG};

	open(my $HIST, '<', $hist_file)
		or die "# ERROR: Could not open '$hist_file': $!\n";

	# $^O or $Config{osname} are based on the platform perl was built on,
	# not where it's currently running.  But this should always be correct
	my $uname = lc((POSIX::uname())[0]);

	while (my $line = <$HIST>) {
		# FIXME: use Munin::Common::Config?
		$line =~ s/#.*//g;
		$line =~ s/^\s+//g;
		$line =~ s/\s+$//g;
		next unless $line =~ /\S/;

		if ($line =~ /^\[([^\]]+)\]$/) {
		    $ver = $1;
		    print "# Setting version to \"$ver\".\n" if $config->{DEBUG};
		    if ($ver eq $config->{newer}) {
			$reached_version = 1;
		    } elsif ($reached_version) {
			$reached_version++;
		    }
		}
		elsif ($reached_version < 2) {
		    next;
		}
		elsif ($line =~ /^([^\/]+)\/(.+)$/) {
		    if ($uname eq $1) {
			$plugins->{$2}->{version} = $ver;
			print "# - Adding plugin '$2' to version tree ",
			  "($ver)...\n" if $config->{DEBUG};
		    }
		}
		elsif ($line =~ /^(.+)$/) {
		    $plugins->{$1}->{version} = $ver;
		    print "# - Adding plugin \"$1\" to version tree ",
		      "($ver)...\n" if $config->{DEBUG};
		}
	}
	close $HIST;
	
	return;
}


# Extracts any magic-markers from $file and notes them.
sub read_magic_markers
{
	my ($info, $file) = @_;
	my $PLUGIN;

	$info->{family} = 'contrib';
	$info->{capabilities} = {};

	print "#\tReading magic markers.\n" if $config->{DEBUG};

	unless (open ($PLUGIN, '<', $file)) {
		warn "WARNING: Could not open plugin '$file' for reading $!.".
			"Skipping.\n";
		return;
	}

	while (<$PLUGIN>) {
		if (/#%#\s+family\s*=\s*(\S+)\s*/) {
			$info->{family} = $1;
			print "#\tSet family to '$1'.\n" if $config->{DEBUG};

		}
		elsif (/#%#\s+capabilities\s*=\s*(.+)/) {
			my @caps = split(/\s+/, $1);
			foreach my $capability (@caps) {
				$info->{capabilities}{$capability} = 1;
			}

			printf "#\tCapabilities are: %s\n", join(', ', @caps)
				if $config->{DEBUG};
		}
	}
	close ($PLUGIN);
	return;
}


sub load_available_plugins
{
	my %found;  # index of plugins found
	
	load_plugin_history() if $config->{newer};

	print "# Searching '$config->{libdir}' for available plugins.\n"
		if $config->{DEBUG};

	opendir (my $LIBDIR, $config->{libdir})
		or die "Fatal: Could not open '$config->{libdir}' for reading: $!\n";

	while (my $plug = readdir $LIBDIR) {
		my $path = "$config->{libdir}/$plug";
		my %plugin;

		unless (Munin::Node::Service->is_a_runnable_service($plug, $config->{libdir})) {
			print "# Ignoring '$path'.\n" if $config->{DEBUG};
			next;
		}

		print "# Considering '$path'\n" if $config->{DEBUG};

		# FIXME: should there ever be symlinks in here?  do we even need
		# care unless we're going to try running it?
		while (-l $path) {
			$path = readlink($path);
			$path = ($path =~ /^\//)
			         ? $path
			         : "$config->{libdir}/$path"
		}

		read_magic_markers(\%plugin, $path);

		unless (grep (/^$plugin{family}$/, @{ $config->{families} })) {
			print "#\tFamily '$plugin{family}' is currently ignored.  Skipping.\n"
				if $config->{DEBUG};
			next;
		}

		if (($plugin{family} eq "auto") and $config->{newer} and $plugin{version}) {
			print "#\tPlugin is older than $config->{newer}.  Skipping.\n"
				if $config->{DEBUG};
			next;
		}

		$found{$plug} = \%plugin;
	}
	close ($LIBDIR);

	printf "# %u plugins available.\n", scalar keys %found
		if $config->{DEBUG};
	return \%found;
}


# Runs the given plugin, and records whether it thinks it should be installed.
# Sets the 'default' and 'defaultreason' fields
sub plugin_autoconf
{
	my ($file, $plugin) = @_;

	my $gotjunk = 0; # did the plugin produce spurious output?

	my @cmd = (
		"$bindir/munin-run",
		"--servicedir", $config->{libdir},
		$file, "autoconf"
	);
	push @cmd, ('--debug') if $config->{DEBUG};

	print "\n# Running: ", join(' ', @cmd), "\n"
		if $config->{DEBUG};

	my $fork = open (my $PLUGIN_OUTPUT, "-|");

	if ($fork == -1) {
		die "ERROR: Unable to fork: $!\n"
	}
	elsif ($fork == 0) {
		# In child
		close (STDERR);
		open (STDERR, ">&STDOUT");

		exec (@cmd);
	}
	else {
		# In parent

		# IFF the plugin exits with non-zero exit code we will
		# not use it no matter what. Instead we report it as
		# an error.  This is to be able to tell a error free
		# execution from a erronous one.
		#
		# Also, if the plugin outputs junk we handle that as
		# an error.
		my @response;

		# FIXME: need to handle plugin not timing out

		while (my $line = <$PLUGIN_OUTPUT>) {
			if ($line =~ /^yes$/
			 or $line =~ /^no(?:\s+.*)?$/)
			{
				# Some recognized response
				print "# Got yes/no: $line"
					if $config->{DEBUG};
				push @response, ($line);
			}
			elsif ($line =~ /^#/) {
				# Likely debug output from munin-run
				print "# munin-run says: $line"
					if $config->{DEBUG};
			}
			else {
				# Something else
				push @errors, ("Got from $file: $line");
				print "# Got junk: $line"
					if $config->{DEBUG};
				$gotjunk = 1;
			}
		}

		$plugin->{'defaultreason'} = join(' ', @response);

		# Do we have a yes?
		if ($plugin->{'defaultreason'} =~ /yes/) {
			$plugin->{'default'} = "yes"
		} else {
			$plugin->{'default'} = "no"
		}
	}
	close ($PLUGIN_OUTPUT);

	my $plugin_status = $?;
	my $plugin_exit   = $? >> 8;
	my $plugin_signal = $? & 127;

	# Override to no if there were errors.
	if ($plugin_status and !$config->{exit_not_error}) {
	    push @errors, ("Non-zero exit value from $file: $plugin_exit/$plugin_signal");
	    print "#\tNon-zero exit value: $plugin_exit/$plugin_signal\n"
	      if $config->{DEBUG};
	}

	if ($plugin_status or $gotjunk) {
	    $plugin->{'default'} = "no";
	}

	print "# ",$plugin->{'default'} if $config->{DEBUG};

	return;
}


# Runs the given wildcard plugin, and returns a list of suggested
# profiles
sub plugin_suggestions
{
	my ($name, $info) = @_;
	my @sugg = ();

	# Only run if the autoconf gave the go-ahead
	return unless (exists $info->{default}
	           and $info->{default} eq "yes");

	my @cmd = (
		"$bindir/munin-run",
		'--servicedir', $config->{libdir},
		$name, 'suggest'
	);

	# Debug here breaks stuff.
	# push(@cmd,'--debug') if $config->{DEBUG};

	print "# Running: ",join(' ', @cmd),"\n" if $config->{DEBUG};

	my $fork = open(my $PLUGIN_OUTPUT, "-|");
	if ($fork == -1) {
		die "ERROR: Unable to fork: $!\n"
	}
	elsif ($fork == 0) {
		# In child
		#
		# We would redirect stderr, but with suggest
		# it's hard to sort errors from the suggestions
		# as we have no idea what the suggestions might
		# be.
		exec (@cmd);
	}
	else {
		# In parent
		while (my $line = <$PLUGIN_OUTPUT>) {
			if ($line =~ m/^#/) {
				# debug output from munin-run
				print "# Got junk: $line"
					if $config->{DEBUG};
			}
			elsif ($line =~ /^[\w\.+]$/) { # FIXME: too restrictive?
				# This ought to be a suggestion.
				print "# Got suggestion: $line"
					if $config->{DEBUG};
				push @sugg, ($line);
			}
			else {
				print "# Got bad suggestion: $line"
					if $config->{DEBUG};
			}
		}
	}
	close ($PLUGIN_OUTPUT);

	if ($?) {
		@sugg = ();
		print "# Plugin exit code: $? - voiding suggestions\n"
			if $config->{DEBUG};
	}

	$info->{suggest} = \@sugg;

	print "# Suggested: ", join (', ', @sugg), "\n"
		if $config->{DEBUG};

	unless (@sugg) {
		print "ERROR: empty suggest from $name\n"
			if $config->{DEBUG};
		push @errors, ("ERROR: empty suggest from $name");
	}

	return;
}


exit main() unless caller;


1;

__END__

=head1 NAME

munin-node-configure - View and modify which plugins are enabled

=head1 SYNOPSIS

munin-node-configure [options]

=head1 OPTIONS

=over 5

=item B<< --help >>

View this help page

=item B<< --version >>

Show version information

=item B<< --debug >>

Print debug information (very verbose).  All debugging output is
printed on STDOUT but each line is prefixed with '#'.  Only errors are
printed on STDERR.

=item B<< --config <file> >>

Override configuration file [@@CONFDIR@@/client.conf]

=item B<< --servicedir <dir> >>

Override plugin dir [@@CONFDIR@@/plugins/]

=item B<< --libdir <dir> >>

Override plugin lib [@@LIBDIR@@/plugins]

=item B<< --families <family,...> >>

Override families [auto]

=item B<< --suggest >>

Show suggestions instead of status

=item B<< --shell >>

Show shell commands (implies --suggest)

=item B<< --remove-also >>

Also show rm-commands when doing --shell

=item B<< --snmp <host|cidr,...> >>

Do SNMP probing on the host or CIDR network (e.g. "192.168.1.0/24"). This
may take some time, especially if the probe includes many hosts. This option
can be specified multiple times, or once with a comma-separated list, to
include more than one host/CIDR.

=item B<< --snmpversion <ver> >>

Set the SNMP version (1, 2c or 3) to use when probing. Default is "2c".

=item B<< --snmpcommunity <comm> >>

Set SNMP community to use when probing. Default is "public".

=back

=head1 DESCRIPTION

Munin's node is a daemon that Munin connects to fetch data. This data is
stored in .rrd-files, and later graphed and htmlified. It's designed to
let it be very easy to graph new datasources.

Munin-node-configure is a script to show the current configuration of which
plugins the host is running, as well as suggestions on what changes to make
to this configuration. It does this by using munin-run(1) to ask the plugins
themselves whether they should be run or not.

=head1 FILES

	@@CONFDIR@@/munin-node.conf
	@@CONFDIR@@/plugin-conf.d/*
	@@CONFDIR@@/plugins/*
	@@LIBDIR@@/plugins/*

=head1 VERSION

This is munin-node-configure v@@VERSION@@.

=head1 AUTHORS

Jimmy Olsen, Nicolai Langfeldt

=head1 BUGS

None known.

=head1 COPYRIGHT

Copyright (C) 2003-2006 Jimmy Olsen, Nicolai Langfeldt.

This is free software; see the source for copying conditions. There is
NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.

This program is released under the GNU General Public License

=cut

