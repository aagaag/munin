#!/usr/bin/perl -w
# -*- perl -*-
#
# Copyright (C) 2003-2006 Jimmy Olsen, Nicolai Langfeldt.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2 dated June,
# 1991.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Program to suggest what plugins to use and not

$| = 1; # Flush after every write to stdout

use strict;
use warnings;

use Getopt::Long;
use POSIX;
use File::Basename;

use Data::Dumper;

use Munin::Node::Config;
use Munin::Node::Service;
use Munin::Common::Defaults;

my $config = Munin::Node::Config->instance();

my $bindir = $Munin::Common::Defaults::MUNIN_SBINDIR;

my ($installed, $plugins);

my @all_families     = ("auto", "manual", "contrib");
my @default_families = ("auto");

my $debugopt   = '--debug'; # Pass --debug to children or not
my @errors     = ();


sub parse_args
{
	my $conffile   = "$Munin::Common::Defaults::MUNIN_CONFDIR/munin-node.conf";
	my $servicedir = "$Munin::Common::Defaults::MUNIN_CONFDIR/plugins";
	my $libdir     = "$Munin::Common::Defaults::MUNIN_LIBDIR/plugins";

	my $debug      = 0;

	my $suggest    = 0;
	my $shell      = 0;
	my $removes    = 0;
	my $newer      = undef;
	my $exiterror  = 1;

	my @families   = ();

	my @snmp       = ();
	my $snmpver    = undef;
	my $snmpcomm   = undef;

	print_usage_and_exit() unless GetOptions(
		"help"            => \&print_usage_and_exit,
		"shell!"          => \$shell,
		"exitnoterror!"   => \$exiterror,
		"debug!"          => \$debug,
		"suggest!"        => \$suggest,
		"config=s"        => \$conffile,
		"servicedir=s"    => \$servicedir,
		"remove-also!"    => \$removes,
		"libdir=s"        => \$libdir,
		"families=s"      => \@families,
		"version!"        => \&print_version_and_exit,
		"snmp=s"          => \@snmp,
		"snmpversion=s"   => \$snmpver,
		"snmpcommunity=s" => \$snmpcomm,
		"newer=s"         => \$newer
	);

	$config->parse_config_from_file($conffile);

	# Sanity-check arguments
	if ($newer and not $newer =~ /^\d+\.\d+\.\d+/) {
		# FIXME: not a very good warning....
		warn "# ERROR: $newer is not a valid argument to --newer.  Ignoring.\n";
		undef $newer;
	}

	if ($newer and (!$shell or $removes)) {
	    print STDERR "Fatal: --newer only supported along with --shell.\n";
	    exit 2;
	}

	if (@snmp and !$shell) {
	    print STDERR "Fatal: --snmp only supported along with --shell.\n";
	    exit 3;
	}


	if (@families) {
	    @families = split /,/, $families[0];
	} else {
	    if (@snmp) {
		@families = ();
		$shell=1;
	    }
	    elsif ($suggest or $shell) {
		@families = @default_families;
	    }
	    else {
		@families = @all_families;
	    }
	}

	$config->reinitialize({
		%$config,

		newer => $newer,
		shell => $shell,
		exit_not_error => $exiterror,
		suggest => $suggest,
		remove_also => $removes,

		families => \@families,

		conffile => $conffile,
		servicedir => $servicedir,
		libdir => $libdir,

		snmp => \@snmp,
		snmp_version => $snmpver,
		snmp_community => $snmpcomm,

		DEBUG => $debug,
	});

	return;
}


sub print_usage_and_exit
{
	my $all_families = join(', ', @all_families);
	my $default_families = join(', ', @default_families);

	print qq{Usage: $0 [options]

Options:
	--help			View this help page
	--version		Show version information
	--debug			View debug information (very verbose)
	--config <file>         Override configuration file
	                        [$config]
	--servicedir <dir>	Override plugin directory
	                        [$Munin::Common::Defaults::MUNIN_CONFDIR/plugins]
	--libdir <dir>		Override plugin lib
	                        [$Munin::Common::Defaults::MUNIN_LIBDIR/plugins]
	--families <family,...>	Override families ($all_families) [$default_families]
	--suggest		Show suggestions instead of status
	--shell			Show shell commands (implies --suggest)
	--exitnoterror          Do not consider non-zero exit-value as error
	--remove-also		Also show rm-commands when doing --shell
	--newer <version>	Only show suggestions related to plugins included
	                        more recently than version <version>.
	--snmp <host|cidr>      Do SNMP probing on the host or CIDR network.
	--snmpversion <ver>     Set SNMP version (1, 2c or 3) [2c]
	--snmpcommunity <comm>  Set SNMP community string [public]

By default this program shows which plugins are activated on the system.

If you specify --suggest, it will present a table of plugins that will
probably work (according to the plugins autoconf command).

If you specify --shell, shell commands to install those same plugins
will be printed. These can be reviewed or piped directly into a shell to
install the plugins.

};

	exit 0;
}


sub print_version_and_exit
{
	print qq{munin-node-configure (munin-node) version $Munin::Common::Defaults::MUNIN_VERSION.
Written by Jimmy Olsen

Copyright (C) 2003-2006 Jimmy Olsen

This is free software released under the GNU General Public License. There
is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE. For details, please refer to the file COPYING that is included
with this software or refer to
  http://www.fsf.org/licensing/licenses/gpl.txt
};

	exit 0;
}


sub print_header
{
	if ($config->{suggest}) {
		normal("Plugin", "Used", "Suggestions");
		normal("------", "----", "-----------");
	}
	else {
		normal("Plugin", "Used", "Extra information");
		normal("------", "----", "-----------------");
	}

	return;
}


sub main
{
	parse_args();

	$plugins   = load_available_plugins();
	$installed = load_installed_plugins();

	print_header() unless $config->{shell};

	if ($config->{suggest}) {
		#print_suggestions();
	}
	elsif (@{ $config->{snmp} }) {
		configure_snmp();
	}
	else {
		# if $config->{shell}, implies $config->{suggest}
		print_status_list();
	}

	exit; # FIXME :-)

	foreach my $plug (sort keys %{$plugins}) {
		# FIXME: next two lines should already be done
		# in load_available_plugins...
		next unless defined $plugins->{$plug}->{'family'};
		next unless (grep (/^$plugins->{$plug}->{'family'}$/ ,@{ $config->{families} }));

		my $now   = (exists $installed->{$plug}?"yes":"no");
		my $want  = (exists $plugins->{$plug}->{'default'}?$plugins->{$plug}->{'default'}:"no");
		my $snow  = (exists $installed->{$plug}->{'suggest'}?$installed->{$plug}->{'suggest'}:undef);
		my $swant = (exists $plugins->{$plug}->{'suggest'}?$plugins->{$plug}->{'suggest'}:undef);
		my $sugg  = "";

		if ($config->{shell}) {
			if ($plug =~ /_$/) {
				# wildcard plugin
				if ($now eq "yes" and $want eq "no") {
					if ($snow and @{$snow}) {
						foreach my $wild (sort @{$snow}) {
							link_remove("$plug$wild");
						}
					}
				}
				else {
					if ($snow and @{$snow}) {
						foreach my $wild (sort @{$snow}) {
							if (! grep (/^$wild$/, @{$swant})) {
								link_remove("$plug$wild");
							}
						}
					}
					if ($swant and @{$swant}) {
						foreach my $wild (sort @{$swant}) {
							next if -e "$config->{servicedir}/$plug"."_".$wild;
							if (! grep (/^$wild$/, @{$snow})) {
								link_add($plug, $wild);
							}
						}
					}
				}
			}
			else {
				if ($now eq "yes" and $want eq "no") {
					link_remove($plug);
				}
				elsif ($now eq "no" and $want eq "yes") {
					next if -e "$config->{servicedir}/$plug"; # None of our business...
					link_add($plug);
				}
			}
		}
		elsif ($config->{suggest}) {
			if ($plug =~ /_$/) {
				# wildcard plugin
				if ($now eq "yes" && $want eq "no"
				 or $now eq "no" && $want eq "yes" && $swant && @{$swant})
				{
					$sugg = "$want ";
				}
				if ($snow and @{$snow}) {
					foreach my $wild (sort @{$snow}) {
						if (! grep (/^$wild$/, @{$swant})) {
							$sugg .= "-$wild ";
						}
					}
				}
				if ($swant and @{$swant}) {
					foreach my $wild (sort @{$swant}) {
						next if -e "$config->{servicedir}/$plug"."_".$wild; # None of our business...
						if (! grep (/^$wild$/, @{$snow})) {
							$sugg .= "+$wild ";
						}
					}
				}
				normal($plug, $now, $sugg);
			}
			else {
				next if -e "$config->{servicedir}/$plug"; # None of our business...
				if ($now ne $want) {
					$sugg = $want;
				}
				elsif (defined $plugins->{$plug}->{'defaultreason'}
				   and $plugins->{$plug}->{'defaultreason'} =~ /^[^\(]*\((.+)\)\s*$/)
				{
					$sugg = "[$1]";
				}

				normal($plug, $now, $sugg);
			}
		}
		else {
			if ($plug =~ /_$/) {
				# wildcard
				if ($snow and @{$snow}) {
					$sugg = join ' ', @{$snow};
				}
				normal($plug, $now, $sugg);
			}
			else {
				normal($plug, $now, "");
			}
		}
	}

	if (@errors) {
		print STDERR "# There were some errors:\n";
		print STDERR "# ",join("\n# ",@errors),"\n";

		exit 1;
	}

	exit 0;
}


sub configure_snmp
{
	unless (-x "$bindir/munin-node-configure-snmp") {
		print STDERR "# ERROR: Cannot perform SNMP probe. SNMP operations require the SNMP part\n";
		print STDERR "# of Munin to be installed, which is currently not installed, or not in the \n";
		print STDERR "# right directory: $bindir\n";

		exit 1;
	}

	unless (eval "require Net::SNMP;") {
		print STDERR "# ERROR: Cannot perform SNMP probe. SNMP operations require the perl module\n";
		print STDERR "# Net::SNMP, which is currently not installed (or not in one of the following\n";
		print STDERR "# directories: @INC\n";

		exit 1;
	}

	my @params;

	push (@params, "$bindir/munin-node-configure-snmp");
	push (@params, "--snmpversion", $config->{snmp_version}) if defined $config->{snmpver};
	push (@params, "--community", $config->{snmp_community}) if defined $config->{snmp_community};
	push (@params, $debugopt) if $config->{DEBUG};
	push (@params, @{ $config->{snmp} });

	print "# executing: ",join(' ',@params),"\n" if $config->{DEBUG};
	exec (@params);

	# Not reached, but just in case...
	exit 42;
}


# For each available plugin, prints a line detailing whether or not it's
# installed, and (if it's a wildcard plugin) what 
sub print_status_list
{
	foreach my $plug (sort keys %{$plugins}) {
		my $now   = $installed->{$plug}
		            ? "yes"
		            : "no";
		my $suggested = $installed->{$plug}->{'suggest'}
		                ? $installed->{$plug}->{'suggest'}
		                : [];

		my $sugg = '';

		if ($plug =~ /_$/ and @$suggested) {
			# It's a wildcard, and there are suggestions
			$sugg = join ' ', @$suggested;
		}
		normal($plug, $now, $sugg);
	}
}


sub link_remove
{
    my $plug = shift;

    return unless $config->{remove_also};
    return unless (-l "$config->{servicedir}/$plug"); # Strange...

    print "rm -f $config->{servicedir}/$plug\n";
}


sub link_add
{
	my $plug = shift;
	my $wild = shift || '';
	print "ln -s $config->{libdir}/$plug $config->{servicedir}/$plug$wild\n";
}


sub normal
{
    printf ("%-26s | %-4s | %-39s\n", @_);
}


sub load_installed_plugins
{
	my %found;  # information on installed plugins
	my $service_count = 0;  # the number of services currently installed
	                        # may not be the same as keys %found
	
	print "# Searching '$config->{servicedir}' for installed plugins.\n"
		if $config->{DEBUG};

	opendir (my $SERVICEDIR, $config->{servicedir})
		or die "ERROR: Could not open '$config->{servicedir}' for reading: $!\n";

	while (my $service = readdir $SERVICEDIR) {
		my $realfile;
		my $path = "$config->{servicedir}/$service";

		# Ignore non-symlinks, and symlinks that point anywhere other
		# than the plugin library
		next unless -l $path;
		unless ($realfile = readlink($path)) {
			print "# Warning: symlink '$config->{servicedir}/$service' is broken.\n";
			next;
		}
		next unless ($realfile =~ /^$config->{libdir}\//);

		$realfile = fileparse($realfile);

		$found{$realfile} ||= {};

		print "# Found '$service'\n" if $config->{DEBUG};

		if ($realfile =~ /_$/) {
			print "#\tWildcard plugin '$service' resolves to '$realfile'\n"
				if $config->{DEBUG};

			# FIXME: doesn't work with snmp__* plugins
			(my $wild = $service) =~ s/^$realfile//;

			print "#\tAdding suggestion '$wild'\n"
				if $config->{DEBUG};

			$found{$realfile}->{wildcard} = 1;

			$found{$realfile}->{suggest} ||= [];
			push @{ $found{$realfile}->{suggest} }, $wild;
		}

		$service_count++;
	}
	close ($SERVICEDIR);

	print "# $service_count services currently installed.\n" if $config->{DEBUG};
	return \%found;
}


sub load_plugin_history
{
	my $hist_file = "$config->{libdir}/plugins.history";
	my $HIST;

	unless ( -f $hist_file) {
		die "# ERROR: Plugin history file '$hist_file' doesn't exist.\n";
	}

	unless (open $HIST, '<', $hist_file) {
		die "# ERROR: Could not open '$hist_file': $!\n";
	}

	my $reached_version = 0;
	my $ver = "0.0.0";

	# $^O or $Config{osname} are based on the platform perl was built on,
	# not where it's currently running.  But this should always be correct
	my $uname = lc((POSIX::uname())[0]);

	while (my $line = <$HIST>) {
		# FIXME: use Munin::Common::Config?
		$line =~ s/#.*//g;
		$line =~ s/^\s+//g;
		$line =~ s/\s+$//g;
		next unless $line =~ /\S/;

		if ($line =~ /^\[([^\]]+)\]$/) {
		    $ver = $1;
		    print "# Setting version to \"$ver\".\n" if $config->{DEBUG};
		    if ($ver eq $config->{newer}) {
			$reached_version = 1;
		    } elsif ($reached_version) {
			$reached_version++;
		    }
		}
		elsif ($reached_version < 2) {
		    next;
		}
		elsif ($line =~ /^([^\/]+)\/(.+)$/) {
		    if ($uname eq $1) {
			$plugins->{$2}->{'version'} = $ver;
			print "# - Adding plugin '$2' to version tree ",
			  "($ver)...\n" if $config->{DEBUG};
		    }
		}
		elsif ($line =~ /^(.+)$/) {
		    $plugins->{$1}->{'version'} = $ver;
		    print "# - Adding plugin \"$1\" to version tree ",
		      "($ver)...\n" if $config->{DEBUG};
		}
	}
	close $HIST;
	return;
}


# FIXME: ewww.  stolen from Munin::Node::Service
# couldn't re-use it directly because it assumes plugins can only be in
# $config->{servicedir}
sub is_a_runnable_plugin
{
	my $file = shift;

	my $path = "$config->{libdir}/$file";

	return unless -f $path && -x _;

	# FIX isn't it enough to check that the file is executable and not
	# in 'ignores'? Can hidden files and config files be
	# unintentionally executable? What does config files do in the
	# service directory? Shouldn't we complain if there is junk in the
	# service directory?
	return if $file =~ m/^\./;               # Hidden files
	return if $file =~ m/.conf$/;            # Config files

	return if $file !~ m/^([-\w.]+)$/;       # Skip if any weird chars
	$file = $1;                              # Not tainted anymore.

	foreach my $regex (@{$config->{ignores}}) {
		return if $file =~ /$regex/;
	}

	return 1;
}


sub read_magic_markers
{
	my $file = shift;
	my (%mm, $PLUGIN);

	print "#\tReading magic markers.\n" if $config->{DEBUG};

	unless (open ($PLUGIN, '<', $file)) {
		warn "WARNING: Could not open plugin '$file' for reading $!.".
			"Skipping.\n";
		next;
	}

	while (<$PLUGIN>) {
		if (/#%#\s+family\s*=\s*(\S+)\s*/) {
			$mm{family} = $1;
		}
		elsif (/#%#\s+capabilities\s*=\s*(.+)/) {
			$mm{capabilities} = [ split (/\s+/, $1) ];
		}
	}

	close ($PLUGIN);

	return \%mm;
}


sub load_available_plugins
{
	my %found;  # index of plugins found
	
	load_plugin_history() if $config->{newer};

	print "# Searching '$config->{libdir}' for available plugins.\n"
		if $config->{DEBUG};

	opendir (my $LIBDIR, $config->{libdir})
		or die "Fatal: Could not open '$config->{libdir}' for reading: $!\n";

	while (my $plug = readdir $LIBDIR) {
		my $path = "$config->{libdir}/$plug";
		my %plugin;

		unless (is_a_runnable_plugin($plug)) {
			print "# Ignoring '$path'.\n" if $config->{DEBUG};
			next;
		}

		print "# Considering '$path'\n" if $config->{DEBUG};

		# FIXME: should there ever be symlinks in here?  do we even need
		# care unless we're going to try running it?
		while (-l $path) {
			$path = readlink($path);
			$path = ($path =~ /^\//)
			         ? $path
			         : "$config->{libdir}/$path"
		}

		my $mm = read_magic_markers($path);

		$plugin{family} = $mm->{family} || "contrib";
		print "#\tSet family to '$plugin{family}'.\n"
			if $config->{DEBUG};

		foreach my $capability (@{ $mm->{capabilities} }) {
			$plugin{capabilities}->{$capability} = 1;
		}

		if ($config->{DEBUG}) {
			my $caps = @{ $mm->{capabilities} }
			           ? join(', ', @{ $mm->{capabilities} })
			           : '<none>';
			print "#\tCapabilities are: $caps\n";
		}

		unless (grep (/^$plugin{family}$/, @{ $config->{families} })) {
			print "#\tFamily '$plugin{family}' is currently ignored.  Skipping.\n"
				if $config->{DEBUG};
			next;
		}

		if ($plugin{family} eq "auto"
		    and defined $config->{newer}
		    and !defined $plugin{version})
		{
			print "#\tPlugin is older than $config->{newer}.  Skipping.\n"
				if $config->{DEBUG};
			next;
		}

#		plugin_autoconf($path, $plugin)
#			if ($plugin{capabilities}->{autoconf});

#		my $suggestions = plugin_suggestions($path, $plugin)
#			if ($plugin{capabilities}->{suggest});
	
		$found{$plug} = \%plugin;
	}
	close ($LIBDIR);

	printf "# %u plugins available.\n", scalar keys %found
		if $config->{DEBUG};
	return \%found;
}


sub plugin_autoconf
{
	my ($file, $plugin) = @_;

	my $gotjunk = 0; # did the plugin produce spurious output?

	my @cmd = (
		"$bindir/munin-run",
		"--servicedir", $config->{libdir},
		$file, "autoconf"
	);

	push @cmd, ($debugopt) if $config->{DEBUG};

	print "\n# Running: ", join(' ', @cmd), "\n"
		if $config->{DEBUG};

	my $fork = open (my $PLUGIN_OUTPUT, "-|");

	if ($fork == -1) {
		die "ERROR: Unable to fork: $!\n"
	}
	elsif ($fork == 0) {
		# In child
		close (STDERR);
		open (STDERR, ">&STDOUT");

		exec (@cmd);
	}
	else {
		# In parent
		#
		# IFF the plugin exits with non-zero exit code we will
		# not use it no matter what. Instead we report it as
		# an error.  This is to be able to tell a error free
		# execution from a erronous one.
		#
		# Also, if the plugin outputs junk we handle that as
		# an error.
		my @response;

		# FIXME: need to handle plugin not timing out

		while (my $line = <$PLUGIN_OUTPUT>) {
			if ($line =~ /^yes$/
			 or $line =~ /^no(?:\s+.*)?$/)
			{
				# Some recognized response
				print "# Got yes/no: $line"
					if $config->{DEBUG};
				push @response, ($line);
			}
			elsif ($line =~ /^#/) {
				# Likely debug output from munin-run
				print "# munin-run says: $line"
					if $config->{DEBUG};
			}
			else {
				# Something else
				push @errors, ("Got from $file: $line");
				print "# Got junk: $line"
					if $config->{DEBUG};
				$gotjunk = 1;
			}
		}

		$plugin->{'defaultreason'} = join(' ', @response);

		# Do we have a yes?
		if ($plugin->{'defaultreason'} =~ /yes/) {
			$plugin->{'default'} = "yes"
		} else {
			$plugin->{'default'} = "no"
		}
	}
	close ($PLUGIN_OUTPUT);

	my $plugin_status = $?;
	my $plugin_exit   = $? >> 8;
	my $plugin_signal = $? & 127;

	# Override to no if there were errors.
	if ($plugin_status and !$config->{exit_not_error}) {
	    push @errors, ("Non-zero exit value from $file: $plugin_exit/$plugin_signal");
	    print "#\tNon-zero exit value: $plugin_exit/$plugin_signal\n"
	      if $config->{DEBUG};
	}

	if ($plugin_status or $gotjunk) {
	    $plugin->{'default'} = "no";
	}

	print "# ",$plugin->{'default'} if $config->{DEBUG};

	return;
}


sub plugin_suggestions
{
	my ($file, $plugin) = @_;
	my @sugg = ();

	return unless (exists $plugin->{'default'}
	           and $plugin->{'default'} eq "yes");

	my @cmd = (
		"$bindir/munin-run",
		"--servicedir", $config->{libdir},
		$file,
		"suggest"
	);

	# Debug here breaks stuff.
	# push(@cmd,$debugopt) if $config->{DEBUG};

	print "# Running: ",join(' ', @cmd),"\n" if $config->{DEBUG};

	my $fork = open(my $PLUGIN_OUTPUT, "-|");
	if ($fork == -1) {
		die "ERROR: Unable to fork: $!\n"
	}
	elsif ($fork == 0) {
		# In child
		#
		# We would redirect stderr, but with suggest
		# it's hard to sort errors from the suggestions
		# as we have no idea what the suggestions might
		# be.
		exec (@cmd);
	}
	else {
		# In parent
		while (my $line = <$PLUGIN_OUTPUT>) {
			if (m/^#/) {
				# debug output from munin-run
				print "# Got junk: $line"
					if $config->{DEBUG};
			}
			else {
				# This ought to be a suggestion.
				print "# Got suggestion: $line"
					if $config->{DEBUG};
				push @sugg, ($line);
			}
		}
	}
	close ($PLUGIN_OUTPUT);

	if ($?) {
		@sugg = ();
		print "# Plugin exit code: $? - voiding suggestions\n"
			if $config->{DEBUG};
	}

	$plugin->{'suggest'} = \@sugg;

	print "# Suggested: ", join (', ', @{$plugin->{'suggest'}}), "\n"
		if $config->{DEBUG};

	print "ERROR: empty suggest from $file\n"
		if $config->{DEBUG};
	push @errors, ("ERROR: empty suggest from $file")
		unless @sugg;
}


exit main() unless caller;


1;

__END__

=head1 NAME

munin-node-configure - View and modify which plugins are enabled

=head1 SYNOPSIS

munin-node-configure [options]

=head1 OPTIONS

=over 5

=item B<< --help >>

View this help page

=item B<< --version >>

Show version information

=item B<< --debug >>

Print debug information (very verbose).  All debugging output is
printed on STDOUT but each line is prefixed with '#'.  Only errors are
printed on STDERR.

=item B<< --config <file> >>

Override configuration file [@@CONFDIR@@/client.conf]

=item B<< --servicedir <dir> >>

Override plugin dir [@@CONFDIR@@/plugins/]

=item B<< --libdir <dir> >>

Override plugin lib [@@LIBDIR@@/plugins]

=item B<< --families <family,...> >>

Override families [auto]

=item B<< --suggest >>

Show suggestions instead of status

=item B<< --shell >>

Show shell commands (implies --suggest)

=item B<< --remove-also >>

Also show rm-commands when doing --shell

=item B<< --snmp <host|cidr,...> >>

Do SNMP probing on the host or CIDR network (e.g. "192.168.1.0/24"). This
may take some time, especially if the probe includes many hosts. This option
can be specified multiple times, or once with a comma-separated list, to
include more than one host/CIDR.

=item B<< --snmpversion <ver> >>

Set the SNMP version (1, 2c or 3) to use when probing. Default is "2c".

=item B<< --snmpcommunity <comm> >>

Set SNMP community to use when probing. Default is "public".

=back

=head1 DESCRIPTION

Munin's node is a daemon that Munin connects to fetch data. This data is
stored in .rrd-files, and later graphed and htmlified. It's designed to
let it be very easy to graph new datasources.

Munin-node-configure is a script to show the current configuration of which
plugins the host is running, as well as suggestions on what changes to make
to this configuration. It does this by using munin-run(1) to ask the plugins
themselves whether they should be run or not.

=head1 FILES

	@@CONFDIR@@/munin-node.conf
	@@CONFDIR@@/plugin-conf.d/*
	@@CONFDIR@@/plugins/*
	@@LIBDIR@@/plugins/*

=head1 VERSION

This is munin-node-configure v@@VERSION@@.

=head1 AUTHORS

Jimmy Olsen, Nicolai Langfeldt

=head1 BUGS

None known.

=head1 COPYRIGHT

Copyright (C) 2003-2006 Jimmy Olsen, Nicolai Langfeldt.

This is free software; see the source for copying conditions. There is
NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.

This program is released under the GNU General Public License

=cut

