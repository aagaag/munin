#!@@PERL@@ -wT
# -*- perl -*-

# Copyright (C) 2004-2009
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2 dated June,
# 1991.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# $Id$
#

use strict;
use warnings;

# Trust PERL5LIB from environment
use lib map { /(.*)/ } split(/:/, ($ENV{PERL5LIB} || ''));

use Getopt::Long;

use Munin::Common::Defaults;
use Munin::Node::Config;
use Munin::Node::OS;

my %services;
my %nodes;

my $servicedir = "$Munin::Common::Defaults::MUNIN_CONFDIR/plugins";
my $sconfdir   = "$Munin::Common::Defaults::MUNIN_CONFDIR/plugin-conf.d";
my $conffile   = "$Munin::Common::Defaults::MUNIN_CONFDIR/munin-node.conf";
my $sconffile  = undef;

my $FQDN       = "";
my $DEBUG      = 0;
my $PIDEBUG    = 0;

my $defuser    = getpwnam($Munin::Common::Defaults::MUNIN_PLUGINUSER);
my $defgroup   = getgrnam($Munin::Common::Defaults::MUNIN_GROUP);

my $paranoia   = 0;
my @ignores    = ();

my %sconf = ();

my $config;
my ($plugin, $arg);

sub main
{
    # "Clean" environment to disable taint-checking on the environment. We _know_
    # that the environment is insecure, but we want to let admins shoot themselves
    # in the foot with it, if they want to.
    foreach my $key (keys %ENV) {
    	$ENV{$key} =~ /^(.*)$/;
    	$ENV{$key} = $1;
    }

    $0 =~ /^(.*)$/;
    $0 = $1;

    # Make build time configuration settings available at runtime.
    Munin::Common::Defaults->export_to_environment();

    parse_args();

    $ENV{'MUNIN_DEBUG'} = $PIDEBUG;

    # Check permissions of configuration
    # FIXME: oops, doesn't honour $paranoia, since it's not yet set in 
    # config object
    unless (Munin::Node::OS->check_perms($servicedir)
         && Munin::Node::OS->check_perms($conffile))
    {
        die "Fatal error. Bailing out.";
    }

    $config = Munin::Node::Config->instance();
    $config->parse_config_from_file($conffile);

    $FQDN     = $config->{fqdn}     if defined $config->{fqdn}; 
    $defuser  = $config->{defuser}  if defined $config->{defuser}; 
    $defgroup = $config->{defgroup} if defined $config->{defgroup}; 
    $paranoia = $config->{paranoia} if defined $config->{paranoia}; 
 
    push @ignores, @{$config->{ignores}} if defined $config->{ignores}; 
 
    if (defined $config->{sconf} && defined $config->{sconf}{timeout}) { 
        $sconf{timeout} = $config->{sconf}{timeout}; 
    } 
 
    if (defined $config->{sconf}) { 
        while (my ($k, $v) = each %{$config->{sconf}}) { 
            next if defined $sconf{$k}; 
            $sconf{$k} = $v; 
        } 
    } 

    # Override the hostname if everything else fails
    $FQDN ||= Munin::Node::OS->get_fq_hostname();

    $ENV{FQDN}=$FQDN;

    $config->reinitialize({
            servicedir => $servicedir,
            sconfdir   => $sconfdir,
            conffile   => $conffile,
            sconffile  => $sconffile,
            fqdn       => $FQDN,
            DEBUG      => $DEBUG,
            PIDEBUG    => $PIDEBUG,
            defuser    => $defuser,
            defgroup   => $defgroup,
            paranoia   => $paranoia,
            ignores    => \@ignores,
            sconf      => \%sconf,
    });

    # Some locales uses "," as decimal separator. This can mess up a lot
    # of plugins.
    $ENV{'LC_ALL'}='C';

    load_services();
}


sub load_services
{
    if ($config->{sconffile}) {
        # FIXME: need method for loading plugin config from a single file
    }
    else {
        $config->process_plugin_configuration_files();
    }

    get_service_list();

    if ($services{$plugin}) {
        print "file: '$plugin'\n" if $config->{DEBUG};
    }
    else {
        print "# ERROR: Plugin '$plugin' doesn't exist.\n";
        exit 1;
    }

    # FIXME: $plugin isn't detainted now.
    my @rows = run_service($services{$plugin}, $arg);

    # shouldn't ever get here.  this is all cruft.
#   my $node = $FQDN;
#   for my $row (@rows) {
#     print "# row: $row\n" if $DEBUG;
#     if ($row =~ m/^host_name (.+)$/) {
#       print "# Found host_name, using it\n" if $DEBUG;
#       $node = $1;
#     }
#   }
#   $nodes{$node}{$plugin}=1;

    print "ERROR: Could not execute plugin.\n";
    exit 1;
}


# returns a hash of plugin-like items in the plugin directory
sub get_service_list
{
    $servicedir = $config->{servicedir};

    opendir my $DIR, $servicedir
        or die "Cannot open plugindir: $servicedir $!";

FILE:
    foreach my $file (readdir($DIR)) {
        # Must be an executable file
        next unless ( -f "$servicedir/$file" && -x _ );

        # FIX isn't it enough to check that the file is executable and
        # not in 'ignores'?
        next if $file =~ m/^\./; # Hidden files
        next if $file =~ m/.conf$/; # Config files
        next if $file !~ m/^([-\w.]+)$/; # Skip if any weird chars
        $file = $1; # Not tainted anymore.

        foreach my $regex (@ignores) {
            next FILE if $file =~ /$regex/;
        }

        # Looks good.  Note it
        $services{$file} = $file;
    }

    close($DIR);

    return \%services;
}


sub run_service {
  my ($service,$command) = @_;
  $command ||="";
  my @lines = ();
  my $timed_out = 0;
  if ($services{$service}) {
    my $child = 0;
    local $SIG{ALRM} = sub { 
      $timed_out = 1; 
    };

    # Setting environment
    $sconf{$service}{user}    = &get_var (\%sconf, $service, 'user');
    $sconf{$service}{group}   = &get_var (\%sconf, $service, 'group');
    $sconf{$service}{command} = &get_var (\%sconf, $service, 'command');
    &get_var (\%sconf, $service, 'env', \%{$sconf{$service}{env}});
    
	if ($< == 0) # If root
	{
		# Giving up gid egid uid euid
		my $u  = (defined $sconf{$service}{'user'}?
			$sconf{$service}{'user'}:
			$defuser);
		my $g  = $defgroup;
		my $gs = "$g $g" .
		  (defined($sconf{$service}{'group'}) ? 
		   " $sconf{$service}{group}" : "");

		print "# Want to run as euid/egid $u/$g\n" if $DEBUG;

		if ($Munin::Common::Defaults::MUNIN_HASSETR)
		{
			$( = $g    unless $g == 0;
			$< = $u    unless $u == 0;
		}
		$) = $gs   unless $g == 0;
		$> = $u    unless $u == 0;

		if ($> != $u or $g != (split (' ', $)))[0])
		{
		print "# Can't drop privileges. Bailing out. (wanted uid=", 
		($sconf{$service}{'user'} || $defuser), " gid=\"", 
		$gs, "\"($g), got uid=$> gid=\"$)\"(", (split (' ', $)))[0], ").\n";
		exit 1;
		}
		print "# Running as uid/gid/euid/egid $</$(/$>/$)\n" if $DEBUG;
		if (! Munin::Node::OS->check_perms("$servicedir/$service"))
		{
			print "# Error: unsafe permissions. Bailing out.";
			exit 1;
		}
	}

    # Setting environment...
    if (exists $sconf{$service}{'env'} and
            defined $sconf{$service}{'env'})
    {
	foreach my $key (keys %{$sconf{$service}{'env'}})
	{
	    print "# Setting environment $key=$sconf{$service}{env}{$key}\n"
	      if $DEBUG;
	    $ENV{$key} = $sconf{$service}{env}{$key};
	}
    }
    if (exists $sconf{$service}{'command'} and
        defined $sconf{$service}{'command'})
    {
	my @run = ();
	foreach my $t (@{$sconf{$service}{'command'}})
	{
	    if ($t =~ /^%c$/)
	    {
		push (@run, "$servicedir/$service", $command);
	    }
	    else
	    {
		push (@run, $t);
	    }
	}
	print "# About to run \"", join (' ', @run), "\"\n" if $DEBUG;
	exec (@run) if @run;
    }
    else
    {
	print "# DEBUG: About to exec \"$servicedir/$service\"\n"
	  if $DEBUG;

	if (!exec ("$servicedir/$service", $command))
	{
	    print "no (could not execute plugin)\n"; exit 1;
	}
    }
  } else {
    print "# Unknown service\n";
  }
  chomp @lines;
  return (@lines);
}


sub get_var
{
    my $sconf   = shift;
    my $name    = shift;
    my $var     = shift;
    my $env     = shift;

    if ($var eq 'env' and !defined $env)
    {
        %{$env} = ();
    }
    
    if ($var ne 'env' and exists $sconf->{$name}{$var})
    {
        return $sconf->{$name}{$var};
    }
    # Deciding environment
    foreach my $wildservice (grep (/\*$/, reverse sort keys %{$sconf}))
    {
        (my $tmpservice = $wildservice) =~ s/\*$//;
        next unless ($name =~ /^$tmpservice/);
        print "# Checking $wildservice...\n" if $DEBUG;

        if ($var eq 'env')
        {
            if (exists $sconf->{$wildservice}{'env'})
            {
                foreach my $key (keys %{$sconf->{$wildservice}{'env'}})
                {
                    if (! exists $sconf->{$name}{'env'}{$key})
                    {
                        $sconf->{$name}{'env'}{$key} = $sconf->{$wildservice}{'env'}{$key};
                        print "# Saving $wildservice->$key\n" if $DEBUG;
                    }
                }
            }
        }
        else
        {
            if (! exists $sconf->{$name}{$var} and
                    exists $sconf->{$wildservice}{$var})
            {
                return ($sconf->{$wildservice}{$var});
            }
        }
    }
    return $env;
}


sub parse_args
{
	print_usage_and_exit() unless GetOptions (
	        "config=s"     => \$conffile,
	        "debug!"       => \$DEBUG,
	        "pidebug!"     => \$PIDEBUG,
	        "version!"     => \&print_version_and_exit,
	        "servicedir=s" => \$servicedir,
	        "sconfdir=s"   => \$sconfdir,
	        "sconffile=s"  => \$sconffile,
	        "paranoia!"    => \$paranoia,
	        "help"         => \&print_usage_and_exit
	);

	print_usage_and_exit() unless $ARGV[0];

    $plugin = $ARGV[0];

    if ($ARGV[1]) {
        # Ensure the plugin's argument (if any) is one of the known ones.
        # Incidentally also makes it taint-safe.
        ($arg) = grep { $_ eq $ARGV[1] } qw/config autoconf snmpconf suggest/;
        warn "# Warning: Unrecognised argument '$ARGV[1]' passed to plugin.\n"
            unless $arg;
    }
}


sub print_version_and_exit
{
    print qq{munin-run (munin-node) version $Munin::Common::Defaults::MUNIN_VERSION.
Written by Audun Ytterdal, Jimmy Olsen, Tore Anderson / Linpro AS

Copyright (C) 2002-2009

This is free software released under the GNU General Public License. There
is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE. For details, please refer to the file COPYING that is included
with this software or refer to
  http://www.fsf.org/licensing/licenses/gpl.txt
};

    exit 0;
}


sub print_usage_and_exit
{
    print qq{Usage: $0 [options] <plugin> [ config | autoconf | snmpconf | suggest ]

Options:
    --help              View this message.
    --config <file>     Use <file> as configuration file.
                        [$Munin::Common::Defaults::MUNIN_CONFDIR/munin-node.conf]
    --servicedir <dir>  Dir where plugins are found.
                        [$Munin::Common::Defaults::MUNIN_CONFDIR/plugins]
    --sconfdir <dir>    Dir where plugin configurations are found.
                        [$Munin::Common::Defaults::MUNIN_CONFDIR/plugin-conf.d]
    --sconffile <file>  Use <file> as plugin configuration. Overrides sconfdir.
                        [undefined]
    --[no]paranoia      Only run plugins owned by root. Check permissions.
                        [--noparanoia]
    --debug             View debug messages
    --pidebug           Plugin debug.  Sets the environment variable
                        MUNIN_DEBUG to 1 so that plugins may enable debugging.
    --version           View version information.
};

    exit 0;
}


exit main() unless caller;


__END__

=head1 NAME

munin-run - A program to run munin-node plugins from the command line

=head1 SYNOPSIS

munin-run [options] <plugin> [ config | autoconf | snmpconf | suggest ]

=head1 OPTIONS

=over 5

=item B<< --config <configfile> >>

Use E<lt>fileE<gt> as configuration file. [@@CONFDIR@@/munin-node.conf]

=item B<< --servicedir <dir> >>

Use E<lt>dirE<gt> as plugin dir. [@@CONFDIR@@/plugins/]

=item B<< --sconfdir <dir> >>

Use E<lt>dirE<gt> as plugin configuration dir. [@@CONFDIR@@/plugin-conf.d/]

=item B<< --sconffile <file> >>

Use E<lt>fileE<gt> as plugin configuration. [undefined]

=item B< --help >

View this help message.

=item B< --debug >

Print debug messages.  Debug messages are sent to both STDOUT and are
prefixed with "#" (this makes it easier for other parts of munin to
use munin-run and still have --debug on).  Only errors go to STDERR.

=item B< --version >

Show version information.

=back

=head1 DESCRIPTION

Munin-node is a daemon that Munin connects to fetch data.  This data
is stored in .rrd-files on the central server , and later graphed and
htmlified.

munin-run is a perlscript to run the plugins used by the munin-node
daemon from the command line.  It's helpful to debug plugins as they
are run the same way with the same user and same environment settings
as within the munin-node.

For more information, see the documentation section at
L<http://munin.sf.net/>.

=head1 FILES

	@@CONFDIR@@/munin-node.conf
	@@CONFDIR@@/plugins/*
	@@CONFDIR@@/plugin-conf.d/*
	@@STATEDIR@@/munin-node.pid
	@@LOGDIR@@/munin-node.log

=head1 VERSION

This is munin-node v@@VERSION@@

=head1 AUTHORS

Audun Ytterdal, Jimmy Olsen, Tore Anderson, Nicolai Langfeldt.

=head1 BUGS

munin-node does, as of now, not check the syntax of the configuration file.

Please report other bugs in the bug tracker at L<http://munin.sf.net/>.

=head1 COPYRIGHT

Copyright (C) 2002-2006 Audun Ytterdal, Jimmy Olsen, Tore Anderson,
Nicolai Langfeldt / Linpro AS.

This is free software; see the source for copying conditions. There is
NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.

This program is released under the GNU General Public License

=cut

# vim:syntax=perl : ts=4 : expandtab
