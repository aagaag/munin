#!@@PERL@@ -w
# -*- perl -*-

=head1 NAME

hddtemp_smartctl - Plugin to monitor harddrive temperatures through
SMART

=head1 CONFIGURATION

The following environment variables are used

 smartctl  - path to smartctl executable
 drives	   - List drives to monitor. E.g. "env.drives hda hdc".
 type_$dev - device type for one drive, e.g. "env.type_sda 3ware,0"
 args_$dev - additional arguments to smartctl for one drive,
             e.g. "env.args_hda -v 194,10xCelsius".  Use this to make
             the plugin use the --all or -a option if your disk will
             not return its temperature when only the -A option is
             used.
 dev_$dev  - monitoring device for one drive, e.g. twe0

If the "smartctl" enviroment variable is not set, or points to a
non-existing file, the plugin will search /usr/bin, /usr/sbin,
/usr/local/bin and /usr/local/sbin for a file called "smartctl", and
use that.

If the "drives" environment variable is not set, the plugin will
attempt to search for drives to probe.

=head1 MAGIC MARKERS

 #%# family=auto
 #%# capabilities=autoconf

=head1 AUTHOR

Copyright (c) 2005, Lutz Peter Christoph
All rights reserved.

=head1 LICENSE

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

  * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in
    the documentation and/or other materials provided with the
    distribution.

  * The name and aliases of Lutz Peter Christoph ("Lupe Christoph",
    "Lutz Christoph") may not be used to endorse or promote products
    derived from this software without specific prior written
    permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=head1 NOTES

Note for users of RAID controllers (smartmontools currently only
supports 3ware): you can specify the drives attached to your RAID
controller(s) as raiddev_num (e.g. sda_0). Then you must specify the
type like this: type_sda_0 3ware,0.

Recent versions of the kernel driver use a separate major device
number for monitoring purposes, like /dev/twe<n> or /dev/twa<n>. This
can be put in the e.g. dev_sda environment variable, to allow the user
to keep sda as the name of the disk.

To avoid spinning up sleeping disks, you need the hdparm command in
your PATH.

=cut

use strict;

my $smartctl = exists $ENV{smartctl} ? $ENV{smartctl} : undef;

# If the envvar is not set, look for smartctl
# first, try $PATH
$smartctl = `which smartctl 2>/dev/null` unless $smartctl;
chomp $smartctl;
$smartctl = undef unless -x $smartctl;

# Still not found? Check obvious places
my @dirs = qw(/usr/bin /usr/sbin /usr/local/bin /usr/local/sbin);
until ($smartctl or @dirs == 0) {
  my $dir = shift @dirs;
  my $path = $dir.'/smartctl';
  $smartctl = $path if -x $path;
}

my @drives;

# Try to get a default set of drives
if ($^O eq 'linux') {
  # On Linux, we know how to enumerate ide drives. SCSI is not as easy
  if (-d '/proc/ide') {
    opendir(IDE, '/proc/ide');
    @drives = grep /hd[a-z]/, readdir IDE;
    closedir(IDE);
  }
  # "SCSI disks" could be both SCSI or SATA - we can't know which
  # without probing them.
} elsif ($^O eq 'freebsd') {
  opendir(DEV, '/dev');
  @drives = grep /^ad[0-9]+$/, readdir DEV;
  closedir(DEV);
} elsif ($^O eq 'solaris') {
  @drives = map { s@.*/@@ ; $_ } glob '/dev/rdsk/c*t*d*s2';
}

@drives = split ' ', $ENV{drives} if exists $ENV{drives};

# Sort list of drives
@drives = sort @drives;

if (defined $ARGV[0]) {
  if ($ARGV[0] eq 'autoconf') {
    if ($smartctl and -x $smartctl) {
      if (@drives) {
        my $cmd = command_for_drive_device($drives[0],
                                           device_for_drive($drives[0]));
        if (`$cmd` =~ /Temperature/) {
          print "yes\n";
        } else {
          print "no (first drive not supported, configure the plugin)\n";
        }
        exit 0;
      } else {
        print "no (no drives known)\n";
        exit 0;
      }
    } else {
      print "no (smartctl not found)\n";
      exit 0;
    }
  } elsif ($ARGV[0] eq 'config') {
    print "graph_title HDD temperature\n";
    print "graph_args --base 1000 -l 0\n";
    print "graph_vlabel temp in °C\n";
    print "graph_category sensors\n";
    print "graph_info This graph shows the temperature in degrees Celsius of the hard drives in the machine.\n";
    print "$_.label $_\n" foreach @drives;
    exit 0;
  }
}

sub device_for_drive {
    my ($drive) = @_;

    my $dev = $drive =~ /(.*)(?:_\d+)/ ? $1 : $drive;

    my $fulldev = '/dev/';
    $fulldev .= 'rdsk/' if $^O eq 'solaris';
    $fulldev .= exists $ENV{'dev_'.$drive} ? $ENV{'dev_'.$drive} : $dev;

    return $fulldev;
}

sub command_for_drive_device {
    my ($drive, $fulldev) = @_;

    my $cmd = $smartctl.' -A ';
    $cmd .= $ENV{'args_'.$drive}.' ' if exists $ENV{'args_'.$drive};
    $cmd .= '-d '.$ENV{'type_'.$drive}.' ' if exists $ENV{'type_'.$drive};
    $cmd .= $fulldev;

}

foreach my $drive (@drives) {
  my $fulldev = device_for_drive($drive);

  # Avoid spinning up sleeping disks only for /dev/sd? or /dev/hd? devices.
  next if $fulldev =~ /\/dev\/[sh]d?/ && `hdparm -C $fulldev 2>/dev/null` =~ /standby/;

  my $cmd = command_for_drive_device($drive, $fulldev);

  my $output = `$cmd`;
  if ($output =~ /Current Drive Temperature:\s*(\d+)/) {
    print "$drive.value $1\n";
  } elsif ($output =~ /^(194 Temperature_Celsius.*)/m) {
    my @F = split ' ', $1;
    print "$drive.value $F[9]\n";
  } elsif ($output =~ /^(231 Temperature_Celsius.*)/m) {
    my @F = split ' ', $1;
    print "$drive.value $F[9]\n";
  }
}
