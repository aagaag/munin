#!@@PERL@@ -Tw
# -*- perl -*-
#
# Copyright (C) 2004-2009 Jimmy Olsen, 
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2 dated June,
# 1991.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# $Id$
#

#

use RRDs;
use Munin::Master::Utils;
use Munin::Common::Defaults;
use strict;
use IO::Handle;
use Date::Manip;
use POSIX qw(strftime);
use IPC::SysV qw(IPC_CREAT);
use CGI::Fast;
use CGI::Carp 'fatalsToBrowser';

my $GRAPHER = "$Munin::Common::Defaults::MUNIN_LIBDIR/munin-graph";
my $conffile = "$Munin::Common::Defaults::MUNIN_CONFDIR/munin.conf";

my %TIMES   = ( "day"   => ["--noweek", "--nomonth", "--noyear", "--nosumweek", "--nosumyear"], 
		"week"  => ["--noday", "--nomonth", "--noyear", "--nosumweek", "--nosumyear"], 
		"month" => ["--noday", "--noweek", "--noyear", "--nosumweek", "--nosumyear"], 
		"year"  => ["--noday", "--noweek", "--nomonth", "--nosumweek", "--nosumyear"],
		"week-sum"  => ["--noday", "--nomonth", "--noyear", "--noweek", "--nosumyear"], 
		"year-sum"  => ["--noday", "--noweek", "--nomonth", "--nosumweek", "--noyear"]
	    );

my %period  = ( "day"   => 300,
		"week"  => 1800,
		"month" => 7200,
		"year"  => 86400,
		"week-sum" => 1800,
		"year-sum" => 86400
	    );

my $log = new IO::Handle;
my $logfile;
my $scale = "day";
my $host  = "";
my $serv  = "";
my $dom   = "";
my $lock  = "";
my $IPC_KEY = 9340;

# NOTE: You need to restart apache if the config file changes!
my $config = &munin_readconfig ($conffile);

# BEGIN FAST-CGI LOOP:
while (new CGI::Fast) {
    my $path = $ENV{PATH_INFO} || "";
    ($dom, $host, $serv, $scale) = $path =~ m#^/(.*)/([^/]+)/(\w+)-([\w=,]+)\.png#; ## avoid bug in vim

    ::logger("asked for ($dom, $host, $serv, $scale)");

    my $pinpoint;
    if ($scale =~ /pinpoint=(\d+),(\d+)/) {
	    $pinpoint = [ $1, $2, ]; 
    }
  
    if (! &verify_parameters ($dom, $host, $serv, $scale)) {
	print "Status: 500\n";
	print "Content-Type: text/html\n";
	print "\n";
	print "Invalid parameters!";
	next;
    }
  
    my $filename = get_picture_filename ($config, $dom, $host, $serv, $scale);
  
    my $time = time;
  
    # If a "Cache-Control: no-cache" header gets send, we regenerate the image in every case:
    my $no_cache = $pinpoint || defined($ENV{HTTP_CACHE_CONTROL}) && $ENV{HTTP_CACHE_CONTROL} =~ /no-cache/i;

    # Compute the cache values
    my $graph_ttl = $pinpoint ? 1 : $period{$scale};
    my $graph_last_expires = $time - $time % $graph_ttl;
 
    my $graph_epoch = (! $no_cache) && file_newer_than($filename, $graph_last_expires);
    if ($graph_epoch) {
	# The graph is fresh enough. Sending either IMS if asked, or just skip generation 
	# Check for If-Modified-Since and send 304 if not changed:
	if (defined $ENV{HTTP_IF_MODIFIED_SINCE} && 
		! rfctime_newer_than($ENV{HTTP_IF_MODIFIED_SINCE}, $graph_epoch)) {
		print "Status: 304\n";
		print "Content-Type: image/png\n";
		print "Content-Length: 0\n";
		my $headers = get_headers_for_file($filename, $graph_ttl);
		
		# Conditionaly add timing informations
		print "Expires: $headers->{Expires}\n";
		print "Last-Modified: " . $headers->{"Last-Modified"} . "\n";

		print "\n";
		# We replied, continue with the next request 
		next;
	}
    } else {
        # Should generate it
	my $scale_options;
	if ($pinpoint) {
		$scale_options = [ "--pinpoint=" . $pinpoint->[0] . "," . $pinpoint->[1] ];
	} else {
		$scale_options = $TIMES{$scale};
	}
	next unless draw_graph_or_complain($dom, $host, $serv, $scale_options, $filename);
    }

    

    # Sending headers
    print "Status: 200\n";
    print "Content-Type: image/png\n";
    my $headers = get_headers_for_file($filename, $graph_ttl);
    foreach my $header_name (keys %$headers) {
	    print "$header_name: $headers->{$header_name}\n";
    }

    print "\n";

    # Sending graph data
    send_graph_data($filename);
}
# END FAST-CGI LOOP

sub get_headers_for_file {
	my $filename = shift;
	my $graph_ttl = shift;
    
	# At this time the file exists and should be served
	my @stats       = stat ($filename);
       	my $mtime_epoch = $stats[9];
       	my $last_modified = get_w3c_date_from_epoch($mtime_epoch);

	# "Expires" has to use last modified time as base:
	my $graph_next_expires = $mtime_epoch - ($mtime_epoch % $graph_ttl) + $graph_ttl;
       	my $expires       = get_w3c_date_from_epoch($graph_next_expires);

	return {
		"Expires" => $expires,
		"Last-Modified" => $last_modified,
		"Content-Length" => $stats[7],
	};
    
}

sub get_w3c_date_from_epoch {
	my $epoch = shift;
	return strftime("%a, %d %b %Y %H:%M:%S GMT", gmtime($epoch));
}

sub send_graph_data {
    # Serve the graph contents.
    my $filename = shift;

    open (GRAPH_PNG_FILE, '<', $filename) or die "Warning: Could not open picture file \"$filename\" for reading: $!\n";
    print while (<GRAPH_PNG_FILE>);
    close (GRAPH_PNG_FILE)
}


sub get_picture_filename {
    my $config  = shift;
    my $domain  = shift;
    my $name    = shift;
    my $service = shift;
    my $scale   = shift;

    my $cgi_tmp_dir = $config->{cgitmpdir} || "/tmp/munin-cgi-tmp";

    return "$cgi_tmp_dir/$domain/$name/$service-$scale.png";
}


sub logger {
  my ($comment) = @_;
  my $now = strftime ("%b %d %H:%M:%S", localtime);

  if ($log->opened)
  {
          print $log "$now - $comment\n";
  }
  else
  {
          if (defined $config->{logdir} && ! $logfile)
          {
		  $logfile = $config->{logdir}. "/munin-cgi-graph.log";
                  if (open ($log, '>>', $logfile))
                  {
                          print $log "$now - $comment\n";
                      }
                  else
                  {
                          print STDERR "Warning: Could not open log file \"$config->{logdir}/munin-cgi-graph.log\" for wr
iting: $!";
                          print STDERR "$now - $comment\n";
			  $logfile = "-:2"; # Set the logfile to STDERR
                  }
          }
          else
          {
                  print STDERR "$now - $comment\n";
          }
    }
}


sub verify_parameters
{
	my $dom   = shift;
	my $host  = shift;
	my $serv  = shift;
	my $scale = shift;

	if (!$dom)
	{
		print STDERR "Warning: Request for graph without specifying domain. Bailing out.\n";
		return 0;
	}
	if (!$host)
	{
		print STDERR "Warning: Request for graph without specifying host. Bailing out.\n";
		return 0;
	}
	if (!$serv)
	{
		print STDERR "Warning: Request for graph without specifying service. Bailing out.\n";
		return 0;
	}

	if (!$scale)
	{
		print STDERR "Warning: Request for graph without specifying scale. Bailing out.\n";
		return 0;
	}
	else
	{
		if (!defined $TIMES{$scale} && $scale !~ /pinpoint=\d+,\d+/)
		{
			print STDERR "Warning: Weird scale setting \"$scale\". Bailing out.\n";
			return 0;
		}
	}
	return 1;
}


sub file_newer_than {
    my $filename = shift;
    my $time     = shift;

    if (-f $filename) {
	my @stats = stat (_);
	# $stats[9] holds the "last update" time and this needs 
	# to be in the last update period
	my $last_update = $stats[9];
	if ($last_update > $time) {
	    return $last_update;
	} else {
	    return 0;
	}
    }

    # No file found
    return 0;
}


sub draw_graph {
    # Draw a new graph - use semaphore to avoid too many concurrent munin-graph calls.
    my $dom  = shift;
    my $host  = shift;
    my $serv  = shift;
    my $scale = shift;

    my $filename = shift;

    # remove old file if present
    if (-f $filename) {
        unlink($filename) or die("cannot remove old graph file: $!");
    }

    $serv =~ s{[^\w_\/"'\[\]\(\)+=-]}{_}g; $serv =~ /^(.+)$/; $serv = $1; #"
    # . needs to be legal in host names
    $host =~ s{[^\w_\/"'\[\]\(\)\.+=-]}{_}g; $host =~ /^(.+)$/; $host = $1; #"

    my $fqn = "root/$dom/$host/$serv";

    my @params = ();
    push @params, @$scale;
    push @params, "--host", $host, "--only-fqn", $fqn;
    push @params, "--no-fork"; # FastCgi forks for us
    push @params, "--skip-locking", "--skip-stats", "--nolazy";
    push @params, "--output-file", $filename;
    push @params, "--log-file", $logfile;

    push @params, "--size_x", CGI::param("size_x") if (CGI::param("size_x"));
    push @params, "--size_y", CGI::param("size_y") if (CGI::param("size_y"));

    push @params, "--upper_limit", CGI::param("upper_limit") if (CGI::param("upper_limit"));
    push @params, "--lower_limit", CGI::param("lower_limit") if (CGI::param("lower_limit"));



    my $file = "/dev/null";

    # Use directly GraphOld;
    use Munin::Master::GraphOld;

    graph_startup(\@params);
    graph_main();

    return $filename;
}


sub draw_graph_or_complain {
    use Time::HiRes qw(gettimeofday tv_interval);
    my $t0 = [ gettimeofday ];
    my $ret = draw_graph(@_);
    my $graph_duration = tv_interval($t0);

    if (! -f $ret) {
	::logger("Warning: Could not draw graph \"$host-$serv-$scale.png\": $ret");
	print "Status: 500\n";
	print "Content-Type: image/png\n";
	print "\n";
        return 0;
    } else {
    	print "X-Graph-Duration: $graph_duration\n";
	return $ret;
    }
}


sub rfctime_newer_than {
    # See if the file has been modified since "the last time".
    # Format of since_string If-Modified-Since: Wed, 23 Jun 2004 16:11:06 GMT
    my $since_string = shift;
    my $created      = shift;
    my $ifmodsec = &UnixDate (&ParseDateString ($since_string), "%s");

    return 1 if ($ifmodsec < $created);
    return 0;
}

# vim: syntax=perl ts=8
