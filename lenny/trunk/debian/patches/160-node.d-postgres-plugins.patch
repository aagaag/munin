Description: Backported plugins from upstream tags/1.3.4. postgres_block_read_,
 postgres_commits_, postgres_connections, postgres_locks, postgres_queries_,
 postgres_space_
Origin: http://munin.projects.linpro.no/browser/tags/1.3.4/node/node.d/

Index: munin-1.2.6/node/node.d/postgres_block_read_.in
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ munin-1.2.6/node/node.d/postgres_block_read_.in	2009-07-27 00:50:56.000000000 +0200
@@ -0,0 +1,167 @@
+#!@@PERL@@ -w
+# -*- perl -*-
+
+# Plugin to monitor PostgreSQL memory usage; gives number of blocks
+# read from disk and from memory, showing how much of the database is
+# served from PostgreSQL's memory buffer.
+#
+# PLEASE NOTE: This plugin may not present the whole truth - the truth
+# may actually be even better than this plugin will show you! That is
+# because PostgreSQL statistics only considers memory block reads from
+# its own allocated memory. When PostgreSQL reads from disk, it may
+# actually still be read from memory, but from the _kernel_'s
+# memory. Summarily, your database server may run even better than
+# this plugin will indicate. See
+# http://www.postgresql.org/docs/7.4/interactive/monitoring-stats.html
+# for a (short) description.
+#
+# Copyright BjØrn Ruberg <bjorn@linpro.no> 2006
+#
+# Licenced under GPL v2.
+#
+# Usage:
+#
+#       Symlink into /etc/munin/plugins/ and add the monitored
+#       database to the filename. e.g.:
+#
+#       ln -s /usr/share/munin/plugins/postgres_block_read_ \
+#         /etc/munin/plugins/postgres_block_read_SomeDatabase
+#       This should, however, be given through autoconf and suggest.
+#
+#       If required, give username, password and/or PostgreSQL server
+#       host through environment variables. 
+# 
+#       You must also activate PostgreSQL statistics. See
+#       http://www.postgresql.org/docs/7.4/interactive/monitoring-stats.html
+#       for how to enable this. Specifically, the following lines must
+#       exist in your postgresql.conf:
+#
+#           stats_start_collector = true
+#           stats_block_level = true
+#
+#
+# Parameters:
+# 	
+# 	config
+# 	autoconf
+#
+# Configuration variables:
+#
+#	PGHOST		- Database server to use. Defaults to using ident
+#			  authentication with the local server.
+#	PGPORT		- Port to connect to. Defaults to '5432'.
+#	PGDATABASE	- Database to connect to. Defaults to 'template1'.
+#	PGUSER		- User to connect as, if necessary.
+#	PGPASSWORD	- Corresponding password to use, if necessary.
+#
+#	(See libpq documentation for more.)
+#	Note that PGDATABASE will default to 'template1' in this plugin, and
+#	without PGHOST it will try ident authentication with the local server,
+#	as the user that the plugin is running as.
+#
+# Configuration example:
+#
+#	# Use local server, ident authentication with the 'postgres' user.
+#	[postgres_*]
+#	user postgres
+#
+#	# Use local server, TCP authentication with a username and password.
+#	[postgres_*]
+#	env.PGHOST localhost
+#	env.PGUSER someuser
+#	env.PGPASSWORD somepassword
+#
+#
+# Magic markers
+#%# family=auto
+#%# capabilities=suggest
+
+use strict;
+use DBI;
+use Data::Dumper;
+use vars qw ( $debug $suggest $configure $dbh );
+
+# Default to template1 database.
+$ENV{'PGDATABASE'} ||= 'template1';
+
+if (exists $ARGV[0]) {
+    if ($ARGV[0] eq 'autoconf') {
+        # Check for DBD::Pg
+        if (! eval "require DBD::Pg;") {
+            print "no (DBD::Pg not found)";
+            exit 1;
+        }
+        # Then we try to detect Postgres presence by connecting to
+        # 'template1'.
+        my $tempdbh = DBI->connect ('dbi:Pg:', '', '');
+        if ($tempdbh) {
+            print "yes\n";
+            exit 0;
+        } else {
+            print "no (Can't connect to given host, please check environment settings)\n";
+            exit 1;
+        }
+    } elsif ($ARGV[0] eq 'debug') {
+        # Set debug flag
+        $debug = 1;
+    } elsif ($ARGV[0] eq 'config') {
+        # Set config flag
+        $configure = 1;
+    } elsif ($ARGV[0] eq 'suggest') {
+        # doesn't always work
+        my @datasources = DBI->data_sources ('Pg');
+        foreach my $dsn (grep !/\=template\d$/, @datasources) {
+            (my $db = $dsn) =~ s/^.*=//;
+            print "$db\n";
+        }
+        exit 0;
+    }
+}
+
+# Must do this here, after checking for autoconf/suggest/etc, because the
+# plugin must be able to run before it is linked to the databases.
+my (undef, undef, undef, $dbname) = split (/_/, $0, 4);
+die "No dbname configured (did you make the proper symlink?)" unless $dbname;
+
+my @datasources = DBI->data_sources ('Pg')
+    or die ("Can't read any possible data sources: $?");
+
+my $dbh = DBI->connect ('dbi:Pg:', '', '', {RaiseError =>1});
+unless($dbh) {
+    die("Error connecting to database (". $DBI::errstr .")\n");
+}
+
+if ($configure) {
+    print <<EOF;
+graph_title Postgres data reads from $dbname
+graph_args --base 1000
+graph_vlabel Blocks read per \${graph_period}
+graph_category PostgreSQL
+graph_info Shows number of blocks read from disk and from memory
+from_disk.label Read from disk
+from_disk.info Read from disk
+from_disk.type DERIVE
+from_disk.min 0
+from_disk.draw AREA
+from_memory.label Cached in memory
+from_memory.info Cached in memory
+from_memory.type DERIVE
+from_memory.min 0
+from_memory.draw STACK
+EOF
+} else {
+    my $sql  = "SELECT (SUM (heap_blks_read) + SUM (idx_blks_read) + ";
+    $sql .= "SUM (toast_blks_read) + SUM (tidx_blks_read)) AS disk, ";
+    $sql .= "(SUM (heap_blks_hit) +SUM (idx_blks_hit) + ";
+    $sql .= "SUM (toast_blks_hit) + SUM (tidx_blks_hit)) AS mem ";
+    $sql .= "from pg_statio_user_tables ";
+    print "# $sql\n" if $debug;
+    my $sth = $dbh->prepare ($sql);
+    $sth->execute();
+    if ($sth->rows > 0) {
+        printf ("# Rows: %d\n",  $sth->rows) if $debug;
+	my ($disk, $mem) = $sth->fetchrow_array();
+	print "from_disk.value $disk\n";
+	print "from_memory.value $mem\n";
+    }
+}
Index: munin-1.2.6/node/node.d/postgres_commits_.in
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ munin-1.2.6/node/node.d/postgres_commits_.in	2009-07-27 00:50:56.000000000 +0200
@@ -0,0 +1,225 @@
+#!@@PERL@@
+# -*- perl -*-
+
+# Plugin to monitor PostgreSQL commits/rollbacks.  
+# 
+# "Why should I care?"
+# - Too many commits can really bog down the database, as it checks all
+# the tables for consitency after each change.  
+# - Software is often set to 'AutoCommit = 1', meaning a commit is done
+# after each transaction.  This is a good idea with brittle code so that
+# you can get some work done if not all, but when you're inserting 10,000
+# rows this can really suck.
+# - If you see a spike in rollbacks, some db programmer is probably
+# abusing their session, or a stored proceudre has gone horribly wrong
+# and isn't leaving a trace.  Time for the rolled-up newspaper.
+
+# Find out more at 
+#  http://www.postgresql.org/docs/8.2/interactive/monitoring-stats.html
+#  (where "8.2" can be the version of PostgreSQL you have installed)
+#
+# BjØrn Ruberg <bjorn@linpro.no> is large and in charge.
+# Licenced under GPL v2.
+#
+# Revision History:
+#  2005/03/10: v0.0001  Vajtsz (from openproject.hu)
+#    "this is my first munin plugin sorry for dummy code"
+#  2007/09/25: v1.0 Moses Moore <moc.iazom@sesom>
+#    Nicolai Langfeldt - "I wounder if one of you would be bothered
+#    to rework [this] over the pattern of postgres_block_read_ ..."
+#    Omitted tracking numbackends because it is an instantaneous
+#    measurement (GAUGE) instead of a cumulative (DERIVE) one.
+#  2007/12/12: v1.01  Tim Retout <tim.retout@credativ.co.uk>
+#    Use libpq environment variables for configuration.
+#
+# Usage:
+#
+#       Symlink into /etc/munin/plugins/ and add the monitored
+#       database to the filename. e.g.:
+#
+#       ln -s /usr/share/munin/plugins/postgres_commits_ \
+#         /etc/munin/plugins/postgres_commits_SomeDatabase
+#       This should, however, be given through autoconf and suggest.
+#
+#       There is an additional means of using this:
+#       if you make the special soft link postgres_commits_All, 
+#       it will plot the commits & rollbacks for all databases 
+#       on this server on one graph.  This isn't recommended, and
+#       will not be offered by 'suggest', but it's here if you want it.
+#
+#       If required, give username, password and/or PostgreSQL server
+#       host through environment variables... but for most sites you
+#       should be able to omit username and password.
+# 
+#       You must also activate PostgreSQL statistics. See
+#       http://www.postgresql.org/docs/8.2/interactive/monitoring-stats.html
+#       for how to enable this. Specifically, the following lines must
+#       exist in your postgresql.conf:
+#
+#           stats_start_collector = true
+#           stats_block_level = true
+#
+#
+# Parameters:
+# 	
+# 	config
+# 	autoconf
+#
+# Configuration variables:
+#
+#	PGHOST		- Database server to use. Defaults to using ident
+#			  authentication with the local server.
+#	PGPORT		- Port to connect to. Defaults to '5432'.
+#	PGDATABASE	- Database to connect to. Defaults to 'template1'.
+#			  Note that this can be different from the database to
+#			  monitor, which is defined via the symlink.
+#	PGUSER		- User to connect as, if necessary.
+#	PGPASSWORD	- Corresponding password to use, if necessary.
+#
+#	(See libpq documentation for more.)
+#	Note that PGDATABASE will default to 'template1' in this plugin, and
+#	without PGHOST it will try ident authentication with the local server,
+#	as the user that the plugin is running as.
+#
+# Configuration example:
+#
+#	# Use local server, ident authentication with the 'postgres' user.
+#	[postgres_*]
+#	user postgres
+#
+#	# Use local server, TCP authentication with a username and password.
+#	[postgres_*]
+#	env.PGHOST localhost
+#	env.PGUSER someuser
+#	env.PGPASSWORD somepassword
+#
+# Magic markers
+#%# family=auto
+#%# capabilities=suggest
+
+use strict;
+use warnings;
+use DBI;
+use Data::Dumper;
+use vars qw ( $debug $suggest $configure $dbh );
+use vars qw ( @datasources );
+
+# Default to template1 database.
+$ENV{'PGDATABASE'} ||= 'template1';
+
+my ($maybe_dbname) = ($0 =~ m/postgres_commits_(\S+)$/);
+if ($maybe_dbname eq 'All' or $ARGV[0] eq 'suggest') {
+  # doesn't always work.
+  my @dsnnames = DBI->data_sources('Pg');
+  foreach my $dsn (grep !/\=template\d$/, @dsnnames) {
+    (my $db = $dsn) =~ s/^.*=//;
+    $db =~ s/"//g; # "
+    $db =~ s/ /\\ /g; # is whitespace allowed in database names?
+    push(@datasources,$db);
+  }
+}
+
+if (exists $ARGV[0]) {
+    if ($ARGV[0] eq 'autoconf') {
+        # Check for DBD::Pg
+        if (! eval "require DBD::Pg;") {
+            print "no (DBD::Pg not found)";
+            exit 1;
+        }
+	# Try to detect PostgreSQL presence.
+        my $tempdbh = DBI->connect ('dbi:Pg:', '', '');
+        if ($tempdbh) {
+            print "yes\n";
+            exit 0;
+        } else {
+            print "no (Can't connect to given host, please check environment settings)\n";
+            exit 1;
+        }
+    } elsif ($ARGV[0] eq 'debug') {
+        # Set debug flag
+        $debug = 1;
+    } elsif ($ARGV[0] eq 'config') {
+        # Set config flag
+        $configure = 1;
+    } elsif ($ARGV[0] eq 'suggest') {
+        if (@datasources) {
+          print join("\n",@datasources)."\n";
+          exit 0;
+        }
+        else {
+          exit 1;
+        }
+    }
+}
+
+die "No dbname configured (did you make the proper symlink?)" unless $maybe_dbname;
+# Note that $dbname is the database being monitored, and can be different from
+# $ENV{'PGDATABASE'}.
+my $dbname = $maybe_dbname unless ($maybe_dbname eq 'All');
+if ($maybe_dbname eq 'All' and not @datasources) {
+  print "# Sorry, can't use the _All trick; no postgresql databases detected.\n";
+  print "# Please make softlinks for each database name.\n";
+  exit 1;
+}
+
+my $dbh = DBI->connect ('dbi:Pg:', '', '', {RaiseError =>1});
+unless($dbh) {
+    die("Error connecting to database. (". $DBI::errstr .")\n");
+}
+
+if ($configure) {
+  print "graph_title Postgres commits/rollbacks on $maybe_dbname\n";
+  print "graph_args --base 1000\n";
+  print "graph_vlabel Sessions per \${graph_period}\n";
+  print "graph_category PostgreSQL\n";
+  print "graph_info Shows number of commits and rollbacks\n";
+  if ($maybe_dbname eq 'All') {
+    foreach my $ds (@datasources) {
+      my ($c,$r) = ($ds."_commits",$ds."_rollbacks");
+      print "$c.label $ds"."_c\n";
+      print "$r.label $ds"."_r\n";
+      print "$c.info Commits on database $ds\n";
+      print "$r.info Rollbacks on database $ds\n";
+      print "$c.min 0\n";
+      print "$r.min 0\n";
+      print "$c.type DERIVE\n";
+      print "$r.type DERIVE\n";
+    }
+  }
+  else {
+    print "commits.label commits\n";
+    print "commits.info SQL sessions terminated with a commit command.\n";
+    print "commits.min 0\n";
+    print "commits.type DERIVE\n";
+    print "rollbacks.label rollbacks\n";
+    print "rollbacks.info SQL sessions terminated with a rollback command.\n";
+    print "rollbacks.min 0\n";
+    print "rollbacks.type DERIVE\n";
+  }
+} elsif ($maybe_dbname eq 'All') {
+    my $sql = "SELECT datname, xact_commit, xact_rollback from pg_stat_database";
+    print "# $sql\n" if $debug;
+    my $sth = $dbh->prepare($sql);
+    $sth->execute();
+    if ($sth->rows > 0) {
+      printf ("# Rows: %d\n",  $sth->rows) if $debug;
+      while (my ($dn,$xc,$xr) = $sth->fetchrow_array()) {
+        next if ($dn =~ /^template\d/); # system-only tables
+        print $dn."_commits.value $xc\n";
+        print $dn."_rollbacks.value $xr\n";
+      }
+    }
+} else {
+    my $sql = "SELECT xact_commit, xact_rollback from pg_stat_database where datname = ?";
+;
+    print "# $sql ($dbname)\n" if $debug;
+    my $sth = $dbh->prepare($sql);
+    $sth->execute($dbname);
+    if ($sth->rows > 0) {
+      printf ("# Rows: %d\n",  $sth->rows) if $debug;
+      my ($xc,$xr) = $sth->fetchrow_array();
+      print "commits.value $xc\n";
+      print "rollbacks.value $xr\n";
+    }
+}
+
Index: munin-1.2.6/node/node.d/postgres_connections.in
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ munin-1.2.6/node/node.d/postgres_connections.in	2009-07-27 00:50:56.000000000 +0200
@@ -0,0 +1,73 @@
+#!@@PERL@@
+# -*- perl -*-
+#
+# Plugin to monitor number of PostgreSQL database connections.
+#
+# Parameters:
+# 	
+# 	config
+# 	autoconf
+#
+# Configuration variables:
+#
+#	PGHOST		- Database server to use. Defaults to using ident
+#			  authentication with the local server.
+#	PGPORT		- Port to connect to. Defaults to '5432'.
+#	PGDATABASE	- Database to connect to. Defaults to 'template1'.
+#	PGUSER		- User to connect as, if necessary.
+#	PGPASSWORD	- Corresponding password to use, if necessary.
+#
+#	(See libpq documentation for more.)
+#	Note that PGDATABASE will default to 'template1' in this plugin, and
+#	without PGHOST it will try ident authentication with the local server,
+#	as the user that the plugin is running as.
+#
+# Configuration example:
+#
+#	# Use local server, ident authentication with the 'postgres' user.
+#	[postgres_*]
+#	user postgres
+#
+#	# Use local server, TCP authentication with a username and password.
+#	[postgres_*]
+#	env.PGHOST localhost
+#	env.PGUSER someuser
+#	env.PGPASSWORD somepassword
+#
+
+use strict;
+use warnings;
+use DBI;
+
+# Default to template1 database.
+$ENV{'PGDATABASE'} ||= 'template1';
+
+my $dbh = DBI->connect ('dbi:Pg:', '','',{RaiseError =>1}) || 
+    die "Unable to access database. Error returned was: ". $DBI::errstr;
+
+if ($ARGV[0] && $ARGV[0] eq 'config') {
+    my $sql_max = "SHOW max_connections;";
+    my $sth_max = $dbh->prepare($sql_max);
+    $sth_max->execute();
+    my ($max_conn) = $sth_max->fetchrow();
+    my $warning = int ($max_conn * 0.7);
+    my $critical = int ($max_conn * 0.8);
+    print <<EOF;
+graph_title Postgres active connections
+graph_args -l 0 --base 1000
+graph_vlabel Active connections
+graph_category PostgreSQL
+graph_info Shows active PostgreSQL connections
+connections.label Active connections
+connections.info Active connections
+connections.type GAUGE
+connections.warning $warning
+connections.critical $critical
+EOF
+} else {
+    my $sql_curr = "SELECT COUNT (*) FROM pg_stat_activity;";
+    my $sth_curr = $dbh->prepare($sql_curr);
+    $sth_curr->execute();
+    my ($curr_conn) = $sth_curr->fetchrow();
+    print "connections.value $curr_conn\n";
+}
Index: munin-1.2.6/node/node.d/postgres_locks.in
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ munin-1.2.6/node/node.d/postgres_locks.in	2009-07-27 00:50:56.000000000 +0200
@@ -0,0 +1,83 @@
+#!@@PERL@@
+# -*- perl -*-
+#
+# Show postgres lock statistics
+#
+# Parameters:
+# 	
+# 	config
+# 	autoconf
+#
+# Configuration variables:
+#
+#	PGHOST		- Database server to use. Defaults to using ident
+#			  authentication with the local server.
+#	PGPORT		- Port to connect to. Defaults to '5432'.
+#	PGDATABASE	- Database to connect to. Defaults to 'template1'.
+#	PGUSER		- User to connect as, if necessary.
+#	PGPASSWORD	- Corresponding password to use, if necessary.
+#
+#	(See libpq documentation for more.)
+#	Note that PGDATABASE will default to 'template1' in this plugin, and
+#	without PGHOST it will try ident authentication with the local server,
+#	as the user that the plugin is running as.
+#
+# Configuration example:
+#
+#	# Use local server, ident authentication with the 'postgres' user.
+#	[postgres_*]
+#	user postgres
+#
+#	# Use local server, TCP authentication with a username and password.
+#	[postgres_*]
+#	env.PGHOST localhost
+#	env.PGUSER someuser
+#	env.PGPASSWORD somepassword
+#
+# Magic markers
+#%# family=auto
+#%# capabilities=suggest
+
+use strict;
+use warnings;
+use DBI;
+
+# Default to template1 database.
+$ENV{'PGDATABASE'} ||= 'template1';
+
+if ($ARGV[0] && $ARGV[0] eq "config") {
+    print <<EOF;
+graph_title Postgres locks
+graph_args --base 1000
+graph_vlabel Locks
+graph_category PostgreSQL
+graph_info Shows PostgreSQL locks
+locks.label Locks
+locks.info Locks (more info here, please... :)
+locks.type GAUGE
+locks.warning 5
+locks.critical 10
+exlocks.label Exclusive locks
+exlocks.info Exclusive locks (here too, please... :)
+exlocks.type GAUGE
+exlocks.warning 5
+exlocks.critical 10
+EOF
+} else {
+    my $dbh = DBI->connect ('dbi:Pg:', '', '', {RaiseError =>1})
+        || die "Unable to access database.\nError returned was: ". $DBI::errstr;
+
+    my $sql="SELECT mode,COUNT(mode) FROM pg_locks GROUP BY mode ORDER BY mode;";
+    my $sth = $dbh->prepare ($sql);
+    $sth->execute ();
+    my $locks = 0;
+    my $exlocks = 0;
+    while (my ($mode, $count) = $sth->fetchrow ()) {
+	if ($mode =~ /exclusive/i) {
+	    $exlocks = $exlocks + $count;
+	}
+	$locks = $locks+$count;
+    }
+    print "locks.value $locks\n";
+    print "exlocks.value $exlocks\n";
+}
Index: munin-1.2.6/node/node.d/postgres_queries_.in
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ munin-1.2.6/node/node.d/postgres_queries_.in	2009-07-27 00:50:56.000000000 +0200
@@ -0,0 +1,194 @@
+#!@@PERL@@
+# -*- perl -*-
+
+# Plugin to monitor PostgreSQL query rate; returns the number of 
+# sequential scans initiated, rows returned by sequential reads,
+# index scans initiated, rows returned by index scans, inserts,
+# updates, and deletes.
+# 
+# Find out more at 
+#  http://www.postgresql.org/docs/8.2/interactive/monitoring-stats.html
+#  (should work with PostgreSQL 7.x and 8.x)
+#
+# BjØrn Ruberg <bjorn@linpro.no> is a mack-daddy.
+# Licenced under GPL v2.
+#
+# Revision History:
+#  2005/03/10: v0.0001  Vajtsz (from openproject.hu)
+#    "this is my first munin plugin sorry for dummy code"
+#  2007/09/25: v1.0 Moses Moore <moc.iazom@sesom>
+#    Nicolai Langfeldt - "I wounder if one of you would be bothered
+#    to rework [this] over the pattern of postgres_block_read_ ..."
+#  2007/12/17 v1.0.1  Tim Retout <tim.retout@credativ.co.uk>
+#    Use libpq environment variables for configuration.
+#
+# Usage:
+#
+#       Symlink into /etc/munin/plugins/ and add the monitored
+#       database to the filename. e.g.:
+#
+#       ln -s /usr/share/munin/plugins/postgres_block_read_ \
+#         /etc/munin/plugins/postgres_block_read_SomeDatabase
+#       This should, however, be given through autoconf and suggest.
+#
+#       If required, give username, password and/or PostgreSQL server
+#       host through environment variables.
+#
+#       You must also activate PostgreSQL statistics. See
+#       http://www.postgresql.org/docs/8.2/interactive/monitoring-stats.html
+#       for how to enable this. Specifically, the following lines must
+#       exist in your postgresql.conf:
+#
+#           stats_start_collector = true
+#           stats_block_level = true
+#
+#
+# Parameters:
+#
+# 	config
+# 	autoconf
+#
+# Configuration variables:
+#
+#	PGHOST		- Database server to use. Defaults to using ident
+#			  authentication with the local server.
+#	PGPORT		- Port to connect to. Defaults to '5432'.
+#	PGDATABASE	- Database to connect to. Defaults to 'template1'.
+#	PGUSER		- User to connect as, if necessary.
+#	PGPASSWORD	- Corresponding password to use, if necessary.
+#
+#	(See libpq documentation for more.)
+#	Note that PGDATABASE will default to 'template1' in this plugin, and
+#	without PGHOST it will try ident authentication with the local server,
+#	as the user that the plugin is running as.
+#
+# Configuration example:
+#
+#	# Use local server, ident authentication with the 'postgres' user.
+#	[postgres_*]
+#	user postgres
+#
+#	# Use local server, TCP authentication with a username and password.
+#	[postgres_*]
+#	env.PGHOST localhost
+#	env.PGUSER someuser
+#	env.PGPASSWORD somepassword
+#
+#
+# Magic markers
+#%# family=auto
+#%# capabilities=suggest
+
+use strict;
+use DBI;
+use Data::Dumper;
+use vars qw ( $debug $suggest $configure $dbh );
+
+# Default to template1 database.
+$ENV{'PGDATABASE'} ||= 'template1';
+
+if (exists $ARGV[0]) {
+    if ($ARGV[0] eq 'autoconf') {
+        # Check for DBD::Pg
+        if (! eval "require DBD::Pg;") {
+            print "no (DBD::Pg not found)";
+            exit 1;
+        }
+        # Then we try to detect Postgres presence.
+        my $tempdbh = DBI->connect ('dbi:Pg:', '', '');
+        if ($tempdbh) {
+            print "yes\n";
+            exit 0;
+        } else {
+            print "no (Can't connect to given host, please check environment settings)\n";
+            exit 1;
+        }
+    } elsif ($ARGV[0] eq 'debug') {
+        # Set debug flag
+        $debug = 1;
+    } elsif ($ARGV[0] eq 'config') {
+        # Set config flag
+        $configure = 1;
+    } elsif ($ARGV[0] eq 'suggest') {
+        # doesn't always work
+        my @datasources = DBI->data_sources ('Pg');
+        foreach my $dsn (grep !/\=template\d$/, @datasources) {
+          (my $db = $dsn) =~ s/^.*=//;
+          $db =~ s/"//g;    # "
+          $db =~ s/ /\\ /g; # is whitespace allowed in database names?
+          print "$db\n";
+        }
+        exit 0;
+    }
+}
+
+# Must do this here, after checking for autoconf/suggest/etc, because the
+# plugin must be able to run before it is linked to the databases.
+my ($dbname) = ($0 =~ m/postgres_queries_(\S+)$/);
+die "No dbname configured (did you make the proper symlink?)" unless $dbname;
+
+my @datasources = DBI->data_sources ('Pg')
+    or die ("Can't read any possible data sources: $?");
+
+my $dbh = DBI->connect ('dbi:Pg:', '', '', {RaiseError =>1});
+unless($dbh) {
+    die("Error connecting to database. (". $DBI::errstr .")\n");
+}
+
+if ($configure) {
+    print <<EOF;
+graph_title Postgres queries on $dbname
+graph_args --base 1000
+graph_vlabel Queries per \${graph_period}
+graph_category PostgreSQL
+graph_info Shows number of select, insert, update and delete queries
+sel_seq.label s_selects
+sel_seq.info Sequential selects on all tables
+sel_seq.type DERIVE
+sel_seq.min 0
+sel_seq_rows.label s_select rows
+sel_seq_rows.info Rows returned from sequential selects
+sel_seq_rows.type DERIVE
+sel_seq.min 0
+sel_idx.label i_selects
+sel_idx.info Sequential selects on all indexes
+sel_idx.type DERIVE
+sel_seq.min 0
+sel_idx_rows.label i_select rows
+sel_idx_rows.info Rows returned form index selects
+sel_idx_rows.type DERIVE
+sel_seq_rows.min 0
+inserts.label inserts
+inserts.info Rows inserted on all tables
+inserts.type DERIVE
+inserts.min 0
+updates.label updates
+updates.info Rows updated on all tables
+updates.type DERIVE
+updates.min 0
+deletes.label deletes
+deletes.info Rows deleted from all tables
+deletes.type DERIVE
+deletes.min 0
+EOF
+} else {
+    my $sql = "SELECT SUM(seq_scan),SUM(seq_tup_read), ";
+    $sql   .= "SUM(idx_scan),SUM(idx_tup_fetch), ";
+    $sql   .= "SUM(n_tup_ins),SUM(n_tup_upd),SUM(n_tup_del) ";
+    $sql   .= "from pg_stat_all_tables";
+    print "# $sql\n" if $debug;
+    my $sth = $dbh->prepare($sql);
+    $sth->execute();
+    if ($sth->rows > 0) {
+      printf ("# Rows: %d\n",  $sth->rows) if $debug;
+      my ($ss, $str, $is, $itf, $nti, $ntu, $ntd) = $sth->fetchrow_array();
+      print "sel_seq.value $ss\n";
+      print "sel_seq_rows.value $str\n";
+      print "sel_idx.value $is\n";
+      print "sel_idx_rows.value $itf\n";
+      print "inserts.value $nti\n";
+      print "updates.value $ntu\n";
+      print "deletes.value $ntd\n";
+    }
+}
+
Index: munin-1.2.6/node/node.d/postgres_space_.in
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ munin-1.2.6/node/node.d/postgres_space_.in	2009-07-27 00:53:09.000000000 +0200
@@ -0,0 +1,219 @@
+#!@@PERL@@ -w
+# -*- perl -*-
+#
+=head1 NAME
+
+postgresql_space_ - Plugin to monitor PostgreSQL disk usage.
+
+=head1 INSTALLATION
+
+Link the plugin to @@CONFDIR@@/plugins/ :
+  ln -s @@LIBDIR@@/plugins/postgres_space_ @@CONFDIR@@/plugins/postgres_space_dbname
+
+The database name from the link is only used in the graph title. You have to
+configure the name of the database to connect in the configuration file. 
+
+=head1 CONFIGURATION
+
+The plugin supports the following parameters:
+	
+ config 	(required)
+ autoconf	(optional - used by munin-node-configure)
+
+
+To configure the plugin set configuration variables in
+@@CONFDIR@@/plugin-conf.d/postgres :
+
+ PGHOST		- Database server to use. Defaults to using ident
+		  authentication with the local server.
+ PGPORT		- Port to connect to. Defaults to '5432'.
+ PGDATABASE	- Database to connect to. Defaults to 'template1'.
+		  Note that this can be different from the database to
+		  monitor, which is defined via the symlink.
+ PGUSER		- User to connect as, if necessary.
+ PGPASSWORD	- Corresponding password to use, if necessary.
+
+(See libpq documentation for more.)
+
+Note that PGDATABASE will default to 'template1' in this plugin, and
+without PGHOST it will try ident authentication with the local server,
+as the user that the plugin is running as.
+
+Configuration example:
+
+# Use local server, ident authentication with the 'postgres' user.
+ [postgres_*]
+ user postgres
+ env.PGDATABASE myappdb
+
+# Use local server, TCP authentication with a username and password.
+ [postgres_*]
+ env.PGHOST localhost
+ env.PGDATABASE myappdb
+ env.PGUSER someuser
+ env.PGPASSWORD somepassword
+
+=head1 AUTHOR
+
+ Written by Bjrn Ruberg (bjorn@linpro.no) 2006
+ Rewritten by Moses Moore 2006-04-08  moc.iazom@sesom
+
+=head1 LICENSE
+
+Licenced under GPL
+
+
+=head1 MAGIC MARKERS
+
+ #%# family=auto
+ #%# capabilities=autoconf suggest
+
+=cut
+
+use strict;
+use DBI;
+use vars qw ( $debug $suggest $configure $dbh );
+
+# Default to template1 database.
+$ENV{'PGDATABASE'} ||= 'template1';
+
+if (exists $ARGV[0]) {
+    if ($ARGV[0] eq 'autoconf') {
+        # Check for DBD::Pg
+        if (! eval "require DBD::Pg;") {
+            print "no (DBD::Pg not found)";
+            exit 0;
+        }
+        # Then we try to detect PostgreSQL presence.
+        my $tempdbh = DBI->connect ('dbi:Pg:', '', '', { PrintError => 0 });
+        if ($tempdbh) {
+            print "yes\n";
+            exit 0;
+        } else {
+            print "no (Can't connect to given host, please check environment settings)\n";
+            exit 0;
+        }
+    } elsif ($ARGV[0] and $ARGV[0] eq 'debug') {
+        # Set config flag
+        $debug = 1;
+    } elsif ($ARGV[0] and $ARGV[0] eq 'config') {
+        # Set config flag
+        $configure = 1;
+    } elsif ($ARGV[0] eq 'suggest') {
+        # doesn't always work
+        my @datasources = DBI->data_sources ('Pg');
+        foreach my $dsn (grep !/\=template\d$/, @datasources) {
+            (my $db = $dsn) =~ s/^.*=//;
+            print "$db\n";
+        }
+        exit 0;
+    }
+}
+
+# Must do this here, after checking for autoconf/suggest/etc, because the
+# plugin must be able to run before it is linked to the databases.
+
+# Note that $dbname is not necessarily the same as $ENV{'PGDATABASE'}.
+my (undef, undef, $dbname) = split (/_/, $0, 3);
+die "No dbname configured (did you make the proper symlink?)" unless $dbname;
+
+my @datasources = DBI->data_sources ('Pg')
+    or die ("Can't read any possible data sources: $?");
+
+my $dbh = DBI->connect ('dbi:Pg:', '', '', {RaiseError =>1});
+unless($dbh) {
+    die("Error connecting to database. (". $DBI::errstr .")\n");
+}
+
+if ($configure) {
+    print <<_EOM;
+graph_title Postgres database $dbname
+graph_args -l 0 --base 1024
+graph_vlabel bytes
+graph_category PostgreSQL
+graph_info Size
+size.label Database size (bytes)
+size.info Database size
+size.type GAUGE
+size.draw AREA
+indexsize.label Index size (bytes)
+indexsize.info Index size
+indexsize.type GAUGE
+indexsize.draw STACK
+metasize.label Meta database size (bytes)
+metasize.info Meta database size
+metasize.type GAUGE
+metasize.draw STACK
+metaindexsize.label Meta index size (bytes)
+metaindexsize.info Meta index size
+metaindexsize.type GAUGE
+metaindexsize.draw STACK
+_EOM
+} else {
+    my $database_pages = 0;
+    my $database_indexes = 0;
+    my $metadatabase_pages = 0;
+    my $metadatabase_indexes = 0;
+    my @names = $dbh->tables;
+    
+    # Find relfilenode and relpages from the given table
+    my $q_ind = "SELECT relkind, relfilenode, relpages FROM pg_class
+                     WHERE relname = ?
+                     UNION
+                     SELECT relkind, relfilenode, relpages FROM pg_class
+                     WHERE relfilenode IN (SELECT indexrelid FROM pg_index 
+                     WHERE indrelid IN (SELECT relfilenode FROM pg_class
+                     WHERE relname = ?))";
+    my $sth = $dbh->prepare ($q_ind) or die $dbh->errstr;
+    
+    # Iterate over the tables in the database
+    foreach my $table (@names) {
+        my $meta = 1;
+        print "#TABLE: $table\n" if $debug;
+        my $table_pages = 0;
+        my $table_indexes = 0;
+        my $metatable_pages = 0;
+        my $metatable_indexes = 0;
+        # "public" tables are the user data
+        $meta = 0 if $table =~ /^public\./;
+        $table =~ s/^.*\.//;
+        
+        # Call the query with $table twice for each side of the UNION
+        $sth->execute ($table, $table) or die $dbh->errstr;
+        while (my ($relkind, $relfilenode, $relpages) = $sth->fetchrow_array) {
+            if ($relkind eq 'r') {
+                $table_pages     += $relpages if $meta == 0;
+                $metatable_pages += $relpages if $meta == 1;
+            } elsif ($relkind eq 'i') {
+                $table_indexes     += $relpages if $meta == 0;
+                $metatable_indexes += $relpages if $meta == 1;
+            }
+            # Define the query
+            my $q2 = "SELECT SUM(relpages) 
+                      FROM pg_class 
+                      WHERE relname IN (?, ?)";
+            my $sth2 = $dbh->prepare ($q2);
+            $sth2->execute ("pg_toast_${relfilenode}",
+                            "pg_toast_${relfilenode}_index");
+            my $relpages = $sth2->fetchrow_array;
+            if ($relkind eq 'r') {
+                $table_pages     += $relpages if defined($relpages) and $meta == 0;
+                $metatable_pages += $relpages if defined($relpages) and $meta == 1;
+            } elsif ($relkind eq 'i') {
+                $table_indexes     += $relpages if defined($relpages) and $meta == 0;
+                $metatable_indexes += $relpages if defined($relpages) and $meta == 1;
+            }
+            print "#\tR:$relfilenode\tP:$table_pages\tI:$table_indexes\n" if $debug;
+        }
+        $database_pages       += $table_pages;
+        $database_indexes     += $table_indexes;
+        $metadatabase_pages   += $metatable_pages;
+        $metadatabase_indexes += $metatable_indexes;
+    }    
+    $sth->finish;
+    $dbh->disconnect;
+    print "size\.value " . $database_pages * 8192 . "\n";
+    print "indexsize\.value " . $database_indexes * 8192 . "\n";
+    print "metasize\.value " . $metadatabase_pages * 8192 . "\n";
+    print "metaindexsize\.value " . $metadatabase_indexes * 8192 . "\n";
+}
